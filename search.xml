<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaWeb | Servlet]]></title>
    <url>%2Fjavaweb-servlet.html</url>
    <content type="text"><![CDATA[JavaWeb-Servlet JavaWeb后端 Servlet JSP MVC JavaWeb会话与状态管理 EL&amp;JSTL 过滤器Filter 监听器Listener Web文件上传下载 国际化 目标：实现Web网上商城 AJAX：局部刷新 JavaWeb概述静态web资源：html 动态web资源：JSP/Servlet、ASP、PHP。 JavaWeb：动态Web资源开发技术。 JavaWeb三大组件：Servlet，Filter，Listener；（全属于动态资源） Servlet容器：Tomcat，确保JAVA_HOME配置正确 第一个Web项目（Eclipse）Dynamic Web Project，New Server：location：tomcat安装目录下wtpwebapp； 配置server.xml的Context： 1&lt;Context docBase="D:\Code\Java\Tomcat\apache-tomcat-9.0.8\wtpwebapps\MyWeb" path="/" reloadable="true" source="org.eclipse.jst.jee.server:MyWeb"/&gt; 虚拟目录配置在tmocat\conf\Catalina\localhost下，自定义一个xml文件： 12&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Context docBase="D:\Code\Java\WebApp\MyWeb" path="/" reloadable="true" source="org.eclipse.jst.jee.server:MyWeb"/&gt; 虚拟主机配置基于主机名的虚拟主机配置：在server.xml中配置多个Host。 基于端口号的虚拟主机配置：在server.xml中配置多个Service。 Web项目打包war包：可以直接拷贝到webapps目录中，会自动解压直接使用tomcat运行。 HTTP协议HTTP超文本传输协议。请求协议+响应协议。请求响应模式 HTTP特点：无连接，无状态。 GET（查）、POST（改）、PUT（增）、DELETE（删）。 GET - 从指定的资源请求数据。一般用于查询资源信息。 POST - 向指定的资源提交要被处理的数据。一般用于更新资源信息。 操作方式 GET POST 数据位置 HTTP包头 HTTP正文 数据加密 明文（数据暴露在URL中） 可明可密 数据安全 不安全 安全 数据长度 1KB以下 无限制 应用场景 查询数据 修改数据 ？HTTPS1.HTTPS协议是什么？ 在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的SSL加密传输协议。 http协议使用80端口，https协议使用443端口。 https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。 2.HTTPS常见加密算法有哪些？ 非对称加密算法（密钥对，客户端用公钥加密数据发送给服务端，服务端用私钥解密数据）：DH、RSA、EL GAML、ECC RSA：是目前最有影响力的公钥加密算法，已被ISO推荐为公钥数据的加密标准。其背后复杂的数学原理，简单来说就是：将2个大素数（质数）相乘非常容易，但要对其乘积结果因式分解非常困难。 对称加密算法（只有一个密钥，加密和解密都用这个密钥）：DES、IDEA、RC2、RC4、SKIPJACK HASH算法，常用的摘要算法：MD5、SHA1、SHA256 3.如何在tomcat中开启HTTPS协议？ 在jdk的安装目录\bin\keytool.exe下打开keytool.exe 在命令行中输入以下命令： 1keytool -genkeypair -alias "tomcat" -keyalg "RSA" -keystore "g:\tomcat.keystore" 配置server.xml： 12345&lt;Connector port="443" protocol="org.apache.coyote.http11.Http11Protocol" SSLEnabled="true" maxThreads="150" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="d:\tomcat.keystore" keystorePass="123456" /&gt; ServletServlet用于处理请求，属于动态资源。 Servlet处理请求过程： 接收请求数据 处理请求 完成响应 Servlet容器：Tomcat； 创建Servlet创建Servlet三种方式： 实现Servlet接口 继承GenericServlet类 继承HttpServlet类 Servlet接口的方法： init() - 用于初始化，只执行一次。 service() - 用于处理请求，请求一次执行一次。 destory() - 用于完成扫尾工作，当Servlet从容器中卸载时执行。 getServletConfig() getServletInfo() Servlet生命周期 Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 Servlet配置当通过浏览器去访问localhost:8080时，tomcat会首先解析web.xml。 12345678910111213141516171819&lt;!--在Servlet容器中注册Servlet--&gt; &lt;servlet&gt; &lt;!--Servlet名称--&gt; &lt;servlet-name&gt;firstName&lt;/servlet-name&gt; &lt;!--Servlet类名--&gt; &lt;servlet-class&gt;com.lizi.web.FirstServlet&lt;/servlet-class&gt; &lt;!--配置servlet的初始化参数--&gt; &lt;init-param&gt; &lt;!--参数名称--&gt; &lt;param-name&gt;hello&lt;/param-name&gt; &lt;!--参数值--&gt; &lt;param-value&gt;world&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--servlet的初始化的时机， 负数，在第一次请求时对servlet初始化 0/正数，在servlet容器启动时对servlet初始化（正数越小，初始化越早） --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 1234567&lt;!--Servlet映射--&gt;&lt;servlet-mapping&gt; &lt;!--Servlet名称--&gt; &lt;servlet-name&gt;firstName&lt;/servlet-name&gt; &lt;!--对应的url地址--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; url-pattern配置： 123&lt;!--通常使用通配符*配置url--&gt;&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;url-pattern&gt;*.action&lt;/url-pattern&gt; ServletRequest servletRequest：封装了请求信息（请求头+请求体）； ServletResponse servletResponse ：封装了响应信息（响应头+响应体）； GenericServletGenericServlet类：抽象service方法，实现其他方法。 继承GenericServlet类：只需实现service方法即可。 Servlet 3.0 配置在开发中两种配置方式：约定 &gt; 配置； 使用注解配置开发Servlet； 使用xml配置开发Servlet Servlet 3.0支持注解配置：约定 &gt; 配置； 12@WebServlet(name = "ServletDemo2" , urlPatterns = &#123;"/demo2","/hello" &#125;)@WebServlet("/demo2") // 未定义参数名，则默认为 urlPatterns。 @WebServlet 约定这是一个Servlet。 HttpServletHttpServlet对http协议提供了特殊支持。 doGet() - Get请求时执行 doPost() - Post请求时执行 Servlet APIServletConfigServletConfig对象由Servlet独享。 1.获取ServletName 1String getServletName(); 2.获取初始化参数值By初始化参数Name 1String getInitParameter(String name); 3.获取所有初始化参数Name 1Enumeration&lt;String&gt; getInitParameterNames(); 枚举 (enum)：有穷可列举。 4.获取ServletContext 1ServletContext getServletContext(); ServletContextServletContext的生命周期贯穿整个web应用，(域对象)。 ServletContext数据被一个web应用中的所有Servlet所共享，(Application域)。 1234&lt;context-param&gt; &lt;param-name&gt;appname&lt;/param-name&gt; &lt;param-value&gt;app&lt;/param-value&gt;&lt;/context-param&gt; 获取ServletContext对象： ServletConfig对象调用getServletContext()方法； HttpServlet子类对象调用getServletContext()方法； ServletContext数据操作： 123void setAttribute(String name, Object value);Object getAttribute(String name);void removeAttribute(String name); 获取资源： 12String getRealPath(String filepath); // 获取资源物理路径InputStream getResourceAsStream(String filepath); // 获取文件流 Request每一次请求创建一个request对象。（域对象） request对象生命周期：发出请求到请求结束。 获取请求头： 1getHeader(); 获取请求URL信息： 12345678910111213141516int getContentLength() // 获取请求体的字节数，GET请求没有请求体，没有请求体返回-1；String getContentType() // 获取请求类型，如果请求是GET，那么这个方法返回null；如果是POST请求，那么默认为application/x-www-form-urlencoded，表示请求体内容使用了URL编码；String getMethod() // 返回请求方法，例如：GETLocale getLocale() // 返回当前客户端浏览器的Locale。java.util.Locale表示国家和言语，这个东西在国际化中很有用；String getCharacterEncoding() //获取请求编码，如果没有setCharacterEncoding()，那么返回null，表示使用ISO-8859-1编码；void setCharacterEncoding(String code) // 设置请求编码，只对请求体有效！注意，对于GET而言，没有请求体！！！所以此方法只能对POST请求中的参数有效！String getContextPath() // 返回上下文路径，例如：/helloString getQueryString() // 返回请求URL中的参数，例如：name=zhangSanString getRequestURI() // 返回请求URI路径，例如：/hello/oneServletStringBuffer getRequestURL() // 返回请求URL路径，例如：http://localhost/hello/oneServlet，即返回除了参数以外的路径信息；String getServletPath() // 返回Servlet路径，例如：/oneServletString getRemoteAddr() // 返回当前客户端的IP地址；String getRemoteHost() // 返回当前客户端的主机名，但这个方法的实现还是获取IP地址；String getScheme() // 返回请求协议，例如：http；String getServerName() // 返回主机名，例如：localhostint getServerPort() // 返回服务器端口号，例如：8080 超链接请求类型为GET类型。 表单Form请求类型可指定请求类型 (GET/POST) 。 123&lt;form action="" method="GET/POST"&gt; 表单域：表单元素；&lt;/form&gt; 文件上传使用POST请求 (文件大小无限制) ； 获取请求表单数据： 12String getParameter(String name); // 通过name获取参数值String[] getParameterValues(String name); // 通过name获取所有同名参数的value属性值 请求转发请求转发：请求转发只发送一次请求，地址栏不发生改变，共享一个request对象。 1request.getRequestDispatcher("/servletDemo2").forward(request,response); parameter参数：网页前台获取的参数。 attribute属性：自己设置的，自己获取的。 请求包含1request.getRequestDispatcher("/servletDemo2").include(request,response); 请求包含多用于JSP页面，完成多页面的合并。 请求转发多用于Servlet中，转发目标大多是JSP页面。 Response设置响应正文字符流 字节流 在一个请求中，不能同时使用两个流。 设置响应头设置状态码重定向客户端发送了两次请求，地址栏发生变化。 重定向第二个请求一定是GET。 中文乱码问题中文乱码产生原因：编码解码字符集不一致。 POST请求中文乱码解决方案：在获取各种参数之前setCharacterEncoding(&quot;UTF-8&quot;)； 1request.setCharacterEncoding("UTF-8"); GET请求中文乱码解决方案：在Tomcat中server.xml中设置URIEncoding = &quot;UTF-8&quot;； 1&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8" / &gt; 字符串解决方案：如果以上两种配置都没用，使用本方法； 12String name = request.getParameter("name");name = new String(name.getBytes("iso-8859-1"),"UTF-8"); 响应内容中文乱码解决方案： 1response.setContentType("text/html;charset=utf-8"); // 设置响应内容的字符集 ？JS提交路径 以/开头：相对主机 不以/开头：相对当前页面路径]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Database | 分页SQL语句]]></title>
    <url>%2Fdb-pagination.html</url>
    <content type="text"><![CDATA[使用数据库SQL语句实现分页功能。 Oracle分页语句Oracle使用ROWNUM伪列实现分页： 123456select * from ( select "temp".*, ROWNUM "rn" from &lt;表/查询块&gt; "temp" where ROWNUM &lt;= currengPage * pageSize ) where "rn" &gt; (currentPage-1) * pageSize currentPage：当前页数。pageSize：每页显示的数据条数。 MySql分页语句MySql使用LIMIT关键字实现分页： 123select *from &lt;表/查询块&gt;limit (currentPage-1)*pageSize, pageSize currentPage：当前页数。pageSize：每页显示的数据条数。]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo | （五）Yilia主题优化]]></title>
    <url>%2Fhexo-yilia-optimization.html</url>
    <content type="text"><![CDATA[yilia主题简单优雅，但是缺少一些我想要的功能，所以我自己稍微扩展了一些功能，比如添加了之前使用的LiveRe评论系统，新增了百度自动推送功能，在文章底部追加了版权声明，勉强实现了相册功能。优化后的yilia主题：https://github.com/liziczh/hexo-theme-yilia add:LiveRe评论系统1.在yilia/layout/_partial/post下添加livere.ejs文件 1234567891011121314&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&lt;%=theme.livere_uid%&gt;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 2.编辑yilia/layout/_partial/article.ejs，在评论代码中引用livere.ejs 1234567&lt;% if (theme.livere_uid)&#123; %&gt; &lt;%- partial(&apos;post/livere&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;&lt;% &#125; %&gt; 3.编辑yilia/_config.yml，添加livere_uid属性 12#0、liveRe评论livere_uid: false add:百度推送1.在yilia/layout/_partial下添加baidu-push.ejs文件 12345678910111213141516&lt;% if (theme.baidu_push)&#123; %&gt;&lt;script&gt;(function()&#123; var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) &#123; bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; &#125; else &#123; bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&lt;% &#125; %&gt; 2.编辑layout/_partial/head.ejs，引用baidu-push.ejs 1&lt;%- partial(&apos;baidu-push&apos;) %&gt; 3.编辑yilia/_config.yml，添加baidu_push属性 12# 百度推送baidu_push: true add:版权声明1.编辑layout/_partial/head.ejs，添加post-copyright代码 1234567891011121314151617&lt;% if (((theme.copyright_type === 2 &amp;&amp; !post.copyright) || (theme.copyright_type === 1 &amp;&amp; post.copyright)) &amp;&amp; !index)&#123; %&gt;&lt;div&gt; &lt;ul class=&quot;post-copyright&quot;&gt; &lt;li&gt; &lt;strong&gt;本文作者：&lt;/strong&gt;&lt;%= config.author%&gt; &lt;/li&gt; &lt;li&gt; &lt;strong&gt;本文链接：&lt;/strong&gt; &lt;a href=&quot;&lt;%= config.url %&gt;&lt;%- url_for(post.path) %&gt;&quot; title=&quot;&lt;%= config.title %&gt;&quot;&gt;&lt;%= config.url %&gt;&lt;%- url_for(post.path) %&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;strong&gt;版权声明： &lt;/strong&gt; 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/3.0/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 3.0&lt;/a&gt; 许可协议。转载请注明出处! &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;% &#125; %&gt; 2.添加.post-copyright的样式 12345678.post-copyright&#123; margin: 0em 0em 0em 0em; padding: 0.5em 1em; border-left:3px solid #ff1700; background-color: #f9f9f9; list-style: none; font-size: 14px;&#125; 3.编辑yilia/_config.yml，添加copyright_type属性 123# 版权声明# type：0-关闭版权声明； 1-存在copyright:true属性的文章，显示版权声明； 2-所有文章均有版权声明copyright_type: 0 new:相册页面（未完成）暂时是直接将以下代码嵌入index.md文档中，勉强实现相册功能。但这样写我自己看着都难受，之后有时间再改。 1.相册图片CSS 1234&lt;style&gt;.img&#123;width:240px;display:inline-block;margin:0 10px 10px 0;&#125;.img-last&#123;width:240px;display:inline-block;margin:0 0 10px 0;&#125;&lt;/style&gt; 2.原生JS实现jQuery入口函数，实现手机图片自适应。 123456789101112131415161718192021222324252627&lt;script&gt;/*原生JS实现jQuery入口函数*/function ready(fn)&#123; if(document.addEventListener&#123; document.addEventListener('DOMContentLoaded',function()&#123; document.removeEventListener('DOMContentLoaded',arguments.callee,false); fn(); &#125;,false);&#125;else if(document.attachEvent)&#123; document.attachEvent('onreadystatechange',function()&#123; if(document.readyState=='complete')&#123; document.detachEvent('onreadystatechange',arguments.callee); fn(); &#125; &#125;);&#125;&#125;; /*手机图片自适应*/ready(function()&#123; var img = document.getElementsByTagName("img"); if(window.screen.width &lt; 500)&#123; for(var i = 0 ; i &lt; img.length;i++)&#123; var len = (window.screen.width-40) / 2; img[i].style.width = len.toString()+"px"; &#125; &#125;&#125;); &lt;/script&gt; new:Ones页面（未完成）单独写一个Ones的静态界面，暂未完成，之后再说。]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java调用阿里ORC接口实现印刷文字识别]]></title>
    <url>%2Fjava-aliorc-impl.html</url>
    <content type="text"><![CDATA[印刷文字识别(ORC)：通俗来讲就是将图片中的印刷文字识别出来。阿里云提供了多种ORC服务，在此使用的是印刷文字识别－文档小说图片文字识别，主要用于企业文档，法律法务文档，信件等，以及小说，文学类书籍等场景的文字识别。 文档小说图片文字识别思路：将图片转化为base64编码，借助阿里ORC接口分析，返回印刷文字的json文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.lizi.orc;import com.lizi.tools.HttpUtils;import org.apache.http.HttpResponse;import org.apache.http.util.EntityUtils;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;import java.io.*;import java.util.HashMap;import java.util.Map;/** * 使用阿里ORC接口实现印刷文档图片转文字 */public class ORCDemo &#123; public static void main(String[] args) &#123; // 将图片转换为base64编码格式 String imgPath = "C:\\Users\\lizic\\Desktop\\2.png"; String imgStr = imgToBase64(imgPath); orc(imgStr); &#125; /** * 阿里ORC接口 */ public static void orc(String imgBase64)&#123; String host = "https://ocrapi-document.taobao.com"; // 阿里接口地址 String path = "/ocrservice/document"; // 具体地址 String method = "POST"; // 请求类型POST String appcode = "你购买的阿里ORC服务的AppCode"; // 产品密钥 Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); //最后在header中的格式(中间是英文空格)为Authorization:APPCODE yourAppCode headers.put("Authorization", "APPCODE " + appcode); //根据API的要求，定义相对应的Content-Type headers.put("Content-Type", "application/json; charset=UTF-8"); Map&lt;String, String&gt; querys = new HashMap&lt;String, String&gt;(); // img 和 url 只能使用一个 String bodys = "&#123;\"img\":\""+imgBase64+"\",\"prob\":false&#125;"; try &#123; /** * HttpUtils下载：https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java * 相关依赖请参照：https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml */ HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys); System.out.println(response.toString()); // 获取response的body System.out.println(EntityUtils.toString(response.getEntity())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 将图片转换为base64字符串 * @param imgPath 编码图片的路径 * @return imgStr 图片的base64编码字符串 */ public static String imgToBase64(String imgPath)&#123; byte[] data = null; InputStream in = null; try &#123; // 将图片读入data中 in = new FileInputStream(new File(imgPath)); data = new byte[in.available()]; in.read(data); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 对data进行Base64编码 BASE64Encoder encoder = new BASE64Encoder(); String imgStr = encoder.encode(data); return imgStr; &#125; /** * 将Base64字符串转换为图片 * @param imgStr 图片的base64编码字符串； * @param imgPath 生成图片的路径 * @return 是否生成图片 */ public static boolean base64ToImg(String imgStr, String imgPath)&#123; if(imgStr == null)&#123; return false; &#125; // 对imgBase64字符串进行解码 OutputStream out = null; try &#123; BASE64Decoder decoder = new BASE64Decoder(); byte[] b = decoder.decodeBuffer(imgStr); for(int i = 0 ; i &lt;b.length ; i++)&#123; // 调整异常数据 if(b[i] &lt; 0)&#123; b[i] += 256; &#125; &#125; // 生成图片文件 out = new FileOutputStream(new File(imgPath)); out.write(b); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Java小程序</category>
      </categories>
      <tags>
        <tag>Java小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用POI实现对Excel文件的读写]]></title>
    <url>%2Fjava-poi-impl.html</url>
    <content type="text"><![CDATA[Apache POI提供了Java程序读取和写入MS Office文档的接口。对于Excel文档读写：-HSSF：提供读写MS Excel的xls文件的功能。-XSSF：提供读写MS Excel的xlsx文件的功能。 Java使用POI实现对Excel文件的读写操作本篇的ExcelUtils工具类，主要针对于一行数据(row)作为一个实例(t)的情况使用。 Excel对象 Java对象 表格（sheet） List&lt;T&gt; 行（row） T 的一个实例 (t) 单元格（cell） 对象 t 的某个属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package com.liziczh.ims.tools;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Field;import java.util.LinkedList;import java.util.List;/** * Excel文件读写工具类：针对一行数据(row)作为一个实例(t)的情况 */public class ExcelUtils &#123; /** * 针对xlsx文件，使用XSSFWorkbook，要求excel版本在2007以上 * * @param T 泛型类，行对象 * @param filepath 文件路径 * @return * @throws Exception */ public static &lt;T&gt; List&lt;T&gt; readExcel(Class T,String filepath)&#123; try &#123; if(filepath != null &amp;&amp; !"".equals(filepath))&#123; // 工作簿 Workbook xwb = new XSSFWorkbook(new FileInputStream(filepath)); // 表格 Sheet sheet = null; // 行 Row row = null; // 单元格 Cell cell = null; // 表 sheet = xwb.getSheetAt(0); List&lt;T&gt; sheetList = new LinkedList&lt;&gt;(); for(int i = sheet.getFirstRowNum()+1; i &lt; sheet.getPhysicalNumberOfRows(); i++)&#123; // 获取第i行 row = sheet.getRow(i); // 利用反射生成一个实例 T t = (T) T.newInstance(); // 依此获取单元格放入对象t中 for(int j = row.getFirstCellNum(); j &lt; row.getPhysicalNumberOfCells(); j++)&#123; // 获取第i行第j列的单元格， cell = row.getCell(j); // 获取对象的属性数组 Field[] fs = t.getClass().getDeclaredFields(); // 设置属性为可访问 fs[j].setAccessible(true); // 类型转换：将单元格内容先转为String再转为当前属性所对应的类型 if(fs[j].getType() == String.class)&#123; fs[j].set(t,fs[j].getType().cast(cell.toString())); &#125; else if (fs[j].getType() == int.class) &#123; fs[j].set(t,new Integer(cell.toString())); &#125; else if(fs[j].getType() == short.class)&#123; fs[j].set(t,new Short(cell.toString())); &#125;else if(fs[j].getType() == long.class)&#123; fs[j].set(t,new Long(cell.toString())); &#125;else if(fs[j].getType() == byte.class)&#123; fs[j].set(t,new Byte(cell.toString())); &#125;else if(fs[j].getType() == float.class)&#123; fs[j].set(t,new Float(cell.toString())); &#125;else if(fs[j].getType() == double.class)&#123; fs[j].set(t,new Double(cell.toString())); &#125; &#125; // 将对象t添加到集合中 sheetList.add(t); &#125; return sheetList; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 针对xlsx文件，使用XSSFWorkbook，要求excel版本在2007以上 * * @param list 数据 * @param T 泛型类，行对象 * @param colNames 表头信息, * @param filepath 文件路径 * @return * @throws Exception */ public static &lt;T&gt; void writeExcel(List&lt;T&gt; list,Class T,String[] colNames,String filepath) &#123; if(filepath != null &amp;&amp; !"".equals(filepath))&#123; // 工作簿 Workbook workbook = new XSSFWorkbook(); // 表格 Sheet sheet = workbook.createSheet("0"); // 行 Row row = null; // 单元格 Cell cell = null; // 设置表头样式 CellStyle headerStyle = workbook.createCellStyle(); headerStyle.setAlignment(HorizontalAlignment.CENTER); Font headerFont = workbook.createFont(); headerFont.setBold(true); headerStyle.setFont(headerFont); // 通过colNames数组生成表头 row = sheet.createRow(0); for (int c = 0; c &lt; colNames.length; c++) &#123; cell = row.createCell(c); cell.setCellValue(colNames[c]); cell.setCellStyle(headerStyle); &#125; // 设置单元格样式 CellStyle cellStyle = workbook.createCellStyle(); cellStyle.setAlignment(HorizontalAlignment.CENTER); // 通过一个List生成表内数据 for (int r = 0; r &lt; list.size(); r++) &#123; // 获取一个List元素（即一个T的实例） T t = list.get(r); // 获取对象t的所有属性 Field[] fs = t.getClass().getDeclaredFields(); // 生成行 row = sheet.createRow(r + 1); // 依此获取对象t的属性值 赋予 单元格 for (int j = 0; j &lt; fs.length; j++) &#123; try &#123; // 设置属性为可访问 fs[j].setAccessible(true); // 生成一个单元格 cell = row.createCell(j); // 将属性值赋予单元格 cell.setCellValue(String.valueOf(fs[j].get(t))); cell.setCellStyle(cellStyle); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 设置表名 workbook.setSheetName(0, T.getName()); // 生成xlsx文件 FileOutputStream out = null; try &#123; out = new FileOutputStream(new File(filepath)); workbook.write(out); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java小程序</category>
      </categories>
      <tags>
        <tag>Java小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle新建数据库]]></title>
    <url>%2Foracle-newdb.html</url>
    <content type="text"><![CDATA[Oracle新建数据库，即新建一块表空间，将表空间分配给某个用户。 1.创建表空间：1234CREATE TABLESPACE &lt;表空间名&gt; DATAFILE &apos;C:\app\oradata\orcl\date.dbf&apos; SIZE &lt;空间&gt;[K|M] [AUTOEXTEND [OFF|ON]]; 2.创建用户：123CREATE USER &lt;用户名&gt; IDENTIFIED BY &lt;密码&gt; DEFAULT TABLESPACE &lt;表空间名&gt; [TEMPORARY TABLESPACE &lt;l临时表空间名&gt;]; 3.将表空间分配给用户：1ALTER USER &lt;用户名&gt; DEFAULT TABLESPACE &lt;表空间名&gt;; 4.给用户授权：12GRANT create session,create table,unlimited tablespace TO &lt;用户名&gt;; 5.用户登陆：1conn &lt;用户名&gt;/&lt;密码&gt;;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java | Tetris]]></title>
    <url>%2Fjava-tetris.html</url>
    <content type="text"><![CDATA[基于 Java-Swing 实现俄罗斯方块GitHub：https://github.com/liziczh/Tetris Preview普通模式： 加速模式： 设计思路方块的属性 方块表示： 由四维数组 SHAPE[][][][] 表示7种方块及每种方块的4种翻转状态。 由SHAPE[type][state]可以唯一标识一个方块。 方块属性： type：方块类型 state：方块翻转状态 (x, y)：方块坐标 nextType：下一方块类型 nextState：下一方块翻转状态 背景块：由map[ROW][COl]表示已固定的背景块。 方块的行为方块翻转：通过改变方块的state属性实现翻转 12345678public void turn() &#123; int temp = state; state = (state + 1) % 4; // 如果旋转后不合法，还原上一状态 if (!check(type, state, x, y)) &#123; state = temp; &#125;&#125; 方块下落：通过改变方块纵坐标实现下落 1234567891011public void down() &#123; // 如果下一个下落状态合法，则下落；不合法，则固定，清行，新建块。 if (check(type, state, x, y + 1)) &#123; y++; &#125; else &#123; fix(type, state, x, y); clearLines(); createShape(); &#125; this.repaint();&#125; 方块左移：通过改变方块横坐标实现左移 12345public void left() &#123; if (check(type, state, x - 1, y)) &#123; x--; &#125;&#125; 方块右移：通过改变方块横坐标实现右移 12345public void right() &#123; if (check(type, state, x + 1, y)) &#123; x++; &#125;&#125; 核心方法实现方块碰撞检测： 12345678910111213private boolean check(int type, int state, int x, int y) &#123; for (int i = 0; i &lt; SHAPE[type][state].length; i++) &#123; for (int j = 0; j &lt; SHAPE[type][state][0].length; j++) &#123; if (SHAPE[type][state][i][j] == 1) &#123; // 在坐标系中小方块坐标(x+j,y+i);在背景矩阵中小方块位置map[y+i][x+j]; if ((x + j &gt;= COL) || (x + j &lt; 0) || (y + i &gt;= ROW) || (map[y + i][x + j] == 1)) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125; 固定当前方块到背景中： 1234567891011private void fix(int type, int state, int x, int y) &#123; for (int i = 0; i &lt; SHAPE[type][state].length; i++) &#123; for (int j = 0; j &lt; SHAPE[type][state][0].length; j++) &#123; // 在坐标系中小方块坐标(x+j,y+i);在背景矩阵中小方块位置map[y+i][x+j]; if ((y + i &lt; ROW) &amp;&amp; (x + j &gt;= 0) &amp;&amp; (x + j &lt; COL) &amp;&amp; (map[y + i][x + j] == 0)) &#123; map[y + i][x + j] = SHAPE[type][state][i][j]; mapColor[y + i][x + j] = color[type]; &#125; &#125; &#125;&#125; 清行加分： 12345678910111213141516171819202122232425private void clearLines() &#123; int lines = 0; boolean isFull = true; for (int i = 0; i &lt; map.length; i++) &#123; isFull = true; for (int j = 0; j &lt; map[0].length; j++) &#123; if (map[i][j] == 0) &#123; isFull = false; break; &#125; &#125; if (isFull) &#123; lines++; for (int m = i; m &gt; 0; m--) &#123; for (int n = 0; n &lt; map[0].length; n++) &#123; map[m][n] = map[m - 1][n]; &#125; &#125; &#125; &#125; score += lines * lines * 10; if (isAccelMode) &#123; up(); &#125;&#125; GUI绘制图形：重写paint()方法，使用Graphics类随意绘制。 Graphics类绘制方法如下： 1234567setColor(Color color); // 设置画笔颜色drawRect(int x,int y,int width,int height); // 绘制矩形边框fillRect(int x,int y,int width,int height); // 填充矩形fill3DRect(int x,int y,int width,int height, boolean raised); // 填充3D矩形。drawLine(x1,y1,x2,y2); // 绘制线条setFont(Font font); // 设置字体drawString(String text, int x, int y); // 绘制字符串 文件目录com.lizich.tetris下： 123.|——TetrisMain # 游戏窗口，由此运行|——TetrisCtrl # 绘制游戏面板&amp;游戏逻辑 com.lizi.tetris.singleclass下： 12.|——Tetris # 合并了TetrisMain与TetrisCtrl 源码TetrisMain 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package com.liziczh.tetris;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import javax.swing.JFrame;import javax.swing.JMenu;import javax.swing.JMenuBar;import javax.swing.JMenuItem;import javax.swing.JOptionPane;public class TetrisMain extends JFrame &#123; /** * 版本号 */ private static final long serialVersionUID = 1L; // 游戏面板 private TetrisCtrl tCtrl = new TetrisCtrl(); /** * 游戏窗口初始化 */ public TetrisMain() &#123; // 设置标题 this.setTitle("Lizi Tetris"); // 设置大小 this.setSize(tCtrl.getSize()); // 调用方法居中 this.setLocationRelativeTo(null); // 设置关闭操作：关闭窗口，程序结束运行； this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体大小不改变 this.setResizable(false); // 添加键盘监听事件 this.addKeyListener(keyListener); // 菜单栏 JMenuBar menu = new JMenuBar(); this.setJMenuBar(menu); JMenu gameMenu = new JMenu("游戏"); JMenuItem newGameItem = gameMenu.add("新游戏"); newGameItem.addActionListener(newGameAction); JMenuItem pauseItem = gameMenu.add("暂停"); pauseItem.addActionListener(pauseAction); JMenuItem continueItem = gameMenu.add("继续"); continueItem.addActionListener(continueAction); JMenuItem exitItem = gameMenu.add("退出"); exitItem.addActionListener(exitAction); JMenu modeMenu = new JMenu("模式"); JMenuItem normalModeItem = modeMenu.add("普通模式"); normalModeItem.addActionListener(normalModeAction); JMenuItem accelModeItem = modeMenu.add("加速模式"); accelModeItem.addActionListener(accelModeAction); JMenu helpMenu = new JMenu("帮助"); JMenuItem aboutItem = helpMenu.add("关于"); aboutItem.addActionListener(aboutAction); menu.add(gameMenu); menu.add(modeMenu); menu.add(helpMenu); // 设置窗口可见 this.setVisible(true); // 添加TetrisPanel this.add(tCtrl); &#125; // 键盘事件监听 KeyListener keyListener = new KeyAdapter() &#123; @Override public void keyPressed(KeyEvent e) &#123; switch (e.getKeyCode()) &#123; case KeyEvent.VK_UP: // ↑：旋转 tCtrl.turn(); tCtrl.repaint(); break; case KeyEvent.VK_LEFT: // ←：左移 tCtrl.left(); tCtrl.repaint(); break; case KeyEvent.VK_RIGHT: // →：右移 tCtrl.right(); tCtrl.repaint(); break; case KeyEvent.VK_DOWN: // ↓：下移 tCtrl.down(); tCtrl.repaint(); break; &#125; &#125; &#125;; // 新游戏 ActionListener newGameAction = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent arg0) &#123; tCtrl.init(); &#125; &#125;; // 暂停 ActionListener pauseAction = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent arg0) &#123; tCtrl.setPause(); &#125; &#125;; // 继续 ActionListener continueAction = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; tCtrl.setContinue(); &#125; &#125;; // 退出 ActionListener exitAction = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.exit(0); &#125; &#125;; // 普通模式 ActionListener normalModeAction = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; tCtrl.setNormal(); &#125; &#125;; // 加速模式 ActionListener accelModeAction = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; tCtrl.setAccel(); &#125; &#125;; // 关于 ActionListener aboutAction = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; JOptionPane.showMessageDialog(tCtrl, "Tetris v1.0 from liziczh", "关于", getDefaultCloseOperation()); &#125; &#125;; public static void main(String[] args) &#123; new TetrisMain(); &#125;&#125; TetrisCtrl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407package com.liziczh.tetris;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.Timer;public class TetrisCtrl extends JPanel &#123; /** * 版本号 */ private static final long serialVersionUID = 1L; // 方块边长，单位像素(px) public final int LEN = 24; // Panel区域：20行10列 public final int ROW = 20; public final int COL = 10; /** * SHAPE[type][state]：方块形状； type方块类型， state方块旋转状态； */ private final int[][][][] SHAPE = new int[][][][] &#123; // S: &#123; &#123; &#123; 0, 1, 1, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 0, 0, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 1, 1, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 0, 0, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125; &#125;, // Z: &#123; &#123; &#123; 1, 1, 0, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 1, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 1, 0, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 1, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125; &#125;, // L: &#123; &#123; &#123; 1, 0, 0, 0 &#125;, &#123; 1, 0, 0, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 1, 1, 0 &#125;, &#123; 1, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 0, 1, 0 &#125;, &#123; 1, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125; &#125;, // J: &#123; &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 0, 0, 0 &#125;, &#123; 1, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 1, 0, 0 &#125;, &#123; 1, 0, 0, 0 &#125;, &#123; 1, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 1, 1, 1, 0 &#125;, &#123; 0, 0, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125; &#125;, // I: &#123; &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125; &#125;, &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 1, 1, 1, 1 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125; &#125;, &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 1, 1, 1, 1 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125; &#125;, // O: &#123; &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125; &#125;, // T: &#123; &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 1, 1, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 0, 1, 1, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 1, 1, 1, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;, &#123; &#123; 0, 1, 0, 0 &#125;, &#123; 1, 1, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125; &#125;, &#125;; // 当前方块的四个参数：type方块类型，state方块旋转状态，坐标(x,y)。 private int type, state, x, y; // 下一个块的参数：nextType方块类型，nextState方块旋转状态 private int nextType, nextState; // 背景：已固定块 private int[][] map = new int[ROW][COL]; // 已固定块的颜色 private Color[][] mapColor = new Color[ROW][COL]; // 得分 private int score = 0; // 等级 private int level = 0; // 下落延时 private int delay = 1000; // 是否在暂停状态 private boolean isPause = false; // 是否为加速模式 private boolean isAccelMode = false; // 方块颜色：color[type] private Color[] color = new Color[] &#123; Color.green, Color.red, Color.orange, Color.blue, Color.cyan, Color.yellow, Color.magenta, Color.gray &#125;; public TetrisCtrl() &#123; // 初始化Panel大小 this.setSize(LEN * 20, LEN * 25); this.init(); &#125; /** * 游戏初始化 */ public void init() &#123; // 初始化背景map for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; map[i][j] = 0; &#125; &#125; // 初始化分数 score = 0; isPause = false; // 随机生成下一方块 nextType = (int) (Math.random() * 7); nextState = (int) (Math.random() * 4); // 生成当前方块 createShape(); // 启动timer timer.start(); // 绘图 this.repaint(); &#125; /** * 创建一个新方块 */ public void createShape() &#123; // 当前块 type = nextType; state = nextState; x = 3; y = 0; // 下一块 nextType = (int) (Math.random() * 7); nextState = (int) (Math.random() * 4); // 如果新块不合法，则表示游戏已结束，则重新开始 if (!check(type, state, x, y)) &#123; JOptionPane.showMessageDialog(this, "GAME OVER!"); init(); &#125; &#125; /** * 判断方块是否合法：true合法，false不合法 */ private boolean check(int type, int state, int x, int y) &#123; for (int i = 0; i &lt; SHAPE[type][state].length; i++) &#123; for (int j = 0; j &lt; SHAPE[type][state][0].length; j++) &#123; if (SHAPE[type][state][i][j] == 1) &#123; // 在坐标系中小方块坐标(x+j,y+i);在背景矩阵中小方块位置map[y+i][x+j]; if ((x + j &gt;= COL) || (x + j &lt; 0) || (y + i &gt;= ROW) || (map[y + i][x + j] == 1)) &#123; return false; &#125; &#125; &#125; &#125; return true; &#125; /** * 固定shape到map */ private void fix(int type, int state, int x, int y) &#123; for (int i = 0; i &lt; SHAPE[type][state].length; i++) &#123; for (int j = 0; j &lt; SHAPE[type][state][0].length; j++) &#123; // 在坐标系中小方块坐标(x+j,y+i);在背景矩阵中小方块位置map[y+i][x+j]; if ((y + i &lt; ROW) &amp;&amp; (x + j &gt;= 0) &amp;&amp; (x + j &lt; COL) &amp;&amp; (map[y + i][x + j] == 0)) &#123; map[y + i][x + j] = SHAPE[type][state][i][j]; mapColor[y + i][x + j] = color[type]; &#125; &#125; &#125; &#125; /** * 消行加分 */ private void clearLines() &#123; int lines = 0; boolean isFull = true; for (int i = 0; i &lt; map.length; i++) &#123; isFull = true; for (int j = 0; j &lt; map[0].length; j++) &#123; if (map[i][j] == 0) &#123; isFull = false; break; &#125; &#125; if (isFull) &#123; lines++; for (int m = i; m &gt; 0; m--) &#123; for (int n = 0; n &lt; map[0].length; n++) &#123; map[m][n] = map[m - 1][n]; &#125; &#125; &#125; &#125; score += lines * lines * 10; if (isAccelMode) &#123; up(); &#125; &#125; /** * 升级加速：UP */ public void up() &#123; int limit = 50; if (score &gt; limit * level) &#123; level++; delay /= 1.5; timer.setDelay(delay); limit = limit * level; &#125; &#125; public void turn() &#123; int temp = state; state = (state + 1) % 4; // 如果旋转后不合法，还原上一状态 if (!check(type, state, x, y)) &#123; state = temp; &#125; &#125; public void down() &#123; // 如果下一个下落状态合法，则下落；不合法，则固定。 if (check(type, state, x, y + 1)) &#123; y++; &#125; else &#123; fix(type, state, x, y); clearLines(); createShape(); &#125; this.repaint(); &#125; public void right() &#123; if (check(type, state, x + 1, y)) &#123; x++; &#125; &#125; public void left() &#123; if (check(type, state, x - 1, y)) &#123; x--; &#125; &#125; /** * 绘图：重写paint()方法 * * @see javax.swing.JComponent#paint(java.awt.Graphics) */ @Override public void paint(Graphics g) &#123; // 游戏区域的左、上边距 int MARGIN_LEFT = LEN; int MARGIN_TOP = LEN + 10; // 边栏的起始坐标 int SIDEBAR_X = LEN * 13;// 文本的横坐标 int SIDEBAR_Y = LEN * 9; // 文本的纵坐标 /** * 填充背景色 */ g.setColor(Color.white); g.fillRect(0, 0, (int) (this.getSize().getWidth()), (int) (this.getSize().getHeight())); /** * 画边框 */ g.setColor(Color.gray); for (int offset = 1; offset &lt; 2; offset++) &#123; // 绘制矩形边框：drawRect(int x,int y,int width,int height); g.drawRect(MARGIN_LEFT - offset, MARGIN_TOP - offset, COL * LEN + offset * 2, ROW * LEN + offset * 2); &#125; /** * 画网状线 */ g.setColor(Color.gray); // 11条竖线 for (int i = 0; i &lt; 11; i++) &#123; // 绘制线条：drawLine(x1,y1,x2,y2); g.drawLine(MARGIN_LEFT + LEN * i, MARGIN_TOP, MARGIN_LEFT + LEN * i, MARGIN_TOP + ROW * LEN); &#125; // 21条横线 for (int i = 0; i &lt; 21; i++) &#123; g.drawLine(MARGIN_LEFT, MARGIN_TOP + LEN * i, MARGIN_LEFT + COL * LEN, MARGIN_TOP + LEN * i); &#125; /** * 画侧栏 */ // 画文本：下一个 g.setColor(Color.gray); g.setFont(new Font("Times", Font.BOLD, 20)); g.drawString("下一个：", SIDEBAR_X, LEN * 2 + 10); // 画提示方块（下一个方块） g.setColor(color[nextType]); for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; if (SHAPE[nextType][nextState][i][j] == 1) &#123; // 填充3D矩形：fill3DRect(int x,int y,int width,int height,boolean raised) g.fill3DRect(SIDEBAR_X + 20 + j * LEN, LEN * 3 + i * LEN, LEN, LEN, true); &#125; &#125; &#125; // 画文本：得分 g.setColor(Color.gray); g.setFont(new Font("Times", Font.BOLD, 24)); g.drawString("等级：" + level, SIDEBAR_X, SIDEBAR_Y); g.drawString("得分：" + score, SIDEBAR_X, SIDEBAR_Y + 40); // 画文本：游戏说明 g.setColor(Color.gray); g.setFont(new Font("Times", Font.BOLD, 15)); g.drawString("玩法：", SIDEBAR_X, SIDEBAR_Y + LEN * 4); g.drawString("上箭头：旋转", SIDEBAR_X, SIDEBAR_Y + LEN * 5); g.drawString("左箭头：左移", SIDEBAR_X, SIDEBAR_Y + LEN * 6); g.drawString("右箭头：右移", SIDEBAR_X, SIDEBAR_Y + LEN * 7); g.drawString("下箭头：下落", SIDEBAR_X, SIDEBAR_Y + LEN * 8); g.drawString("@栗子", SIDEBAR_X, SIDEBAR_Y + LEN * 10); // 画当前下落块 g.setColor(color[type]); for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; if (SHAPE[type][state][i][j] == 1) &#123; g.fill3DRect(MARGIN_LEFT + (x + j) * LEN, MARGIN_TOP + (y + i) * LEN, LEN, LEN, true); &#125; &#125; &#125; // 画背景map for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; if (map[i][j] == 1) &#123; g.setColor(mapColor[i][j]); g.fill3DRect(MARGIN_LEFT + j * LEN, MARGIN_TOP + i * LEN, LEN, LEN, true); &#125; &#125; &#125; // 画暂停 if (isPause) &#123; g.setColor(Color.black); g.drawString("PAUSE", MARGIN_LEFT + LEN * 8, LEN); &#125; // 画普通模式 if (!isAccelMode) &#123; g.setColor(Color.black); g.drawString("Normal Mode", LEN, LEN); &#125; // 画加速模式 if (isAccelMode) &#123; g.setColor(Color.black); g.drawString("Accel Mode", LEN, LEN); &#125; &#125; /** * 定时器 */ Timer timer = new Timer(delay, new ActionListener() &#123; // 定时器任务 @Override public void actionPerformed(ActionEvent e) &#123; down(); &#125; &#125;); // 暂停 public void setPause() &#123; timer.stop(); isPause = true; this.repaint(); &#125; // 继续 public void setContinue() &#123; timer.restart(); isPause = false; this.repaint(); &#125; // 简单模式 public void setNormal() &#123; isAccelMode = false; level = 0; timer.setDelay(1000); init(); &#125; // 加速模式 public void setAccel() &#123; isAccelMode = true; level = 1; timer.setDelay(500); init(); &#125;&#125; emmmmmm……不好意思，寒假作业，快到暑假了才完成。]]></content>
      <categories>
        <category>Java小程序</category>
      </categories>
      <tags>
        <tag>Java小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2Fjdbc.html</url>
    <content type="text"><![CDATA[JDBC（Java Database Connectivity ，Java数据库连接），一种用于执行SQL语句的Java API，为访问不同的关系型数据库提供了统一规范。 JDBC 简介JDBC 提供了两种规范： JDBC API：提供了应用程序与 JDBC 管理器的连接，供开发人员连接数据库、执行SQL语句、获得结果。 JDBC Driver API：提供了 JDBC 管理器与驱动程序的连接，供数据库厂商开发数据库驱动程序使用。 数据库厂商通过 JDBC Driver API 开发相应的数据库驱动程序，开发人员只需导入数据库驱动程序，即可使用 JDBC API 编写代码操纵该数据库。 JDBC API 组件 DriverManager：此接口用于管理一系列数据库驱动程序。匹配连接使用通信子协议从Java应用程序请求相应的数据库驱动程序。识别JDBC在某个子协议的第一个驱动程序将被用来建立数据库连接。 Driver：此接口用于处理与数据库服务器的通信。很少直接直接使用驱动程序（Driver）对象，一般使用DriverManager中的对象。 Connection：此接口拥有接触数据库的所有方法。连接对象表示通信上下文，即与数据库中的所有的通信是通过此唯一的连接对象。 Statement：创建该接口对象将SQL语句提交到数据库。 ResultSet：保存使用Statement对象执行SQL查询的结果集，可迭代结果集。 SQLException：用于处理发生在数据库应用程序中的错误。 JDBC 连接数据库前提：安装由数据库厂商提供的数据库驱动程序 (导入数据库驱动jar包)。 JDBC 连接数据库步骤： 加载和注册驱动 获取数据库连接 执行sql语句 处理结果集 释放资源 JDBC 简单示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class JDBCDemo &#123; public static void main(String[] args) &#123; // 声明变量 Connection conn = null; Statement stat = null; ResultSet res = null; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); try &#123; // 1.加载和注册驱动 String driverClassName = "com.mysql.jdbc.Driver"; Class.forName(driverClassName); // 2.获取数据库连接 String url = "jdbc:mysql:///lizi"; String ur = "root"; String pwd = "root"; conn = DriverManager.getConnection(url, ur, pwd); // 3.执行sql查询语句 stat = conn.createStatement(); String sql = " select * from user "; res = stat.executeQuery(sql); // 4.迭代处理结果集 while(res.next()) &#123; User user = new User(); user.setId(res.getInt("id")); user.setUsername(res.getString("username")); user.setPassword(res.getString("password")); userList.add(user); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; // 5.关闭连接，释放资源 try &#123; // 释放结果集 res.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; // 释放statement对象 stat.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; try &#123; // 关闭数据库连接 conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 1.加载和注册驱动使用 DriverManager.registerDriver() 加载和注册驱动： Oracle： 123// 注册Oracle驱动Driver oracleDriver = new oracle.jdbc.driver.OracleDriver();DriverManager.registerDriver(oracleDriver); MySql： 123// 注册MySql驱动Driver mysqlDriver = new com.mysql.jdbc.Driver();DriverManager.registerDriver(mysqlDriver); 使用 Class.forName() 加载和注册驱动： Oracle： 123// 加载和注册Oracle驱动String driverClassName = "oracle.jdbc.driver.OracleDriver";Class.forName(driverClassName); MySql： 123// 加载和注册MySql驱动String driverClassName = "com.mysql.jdbc.Driver";Class.forName(driverClassName); 推荐使用 Class.forName() 加载驱动。 2.获取数据库连接（1）使用 *.properties 文件配置数据库属性 Oracle： 1234driverClassName=oracle.jdbc.driver.OracleDriverurl=jdbc:oracle:thin:@192.168.124.15:1521:orclusername=scottpassword=tiger MySql： 1234driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/lizi?useUnicode=true&amp;characterEncode=utf8&amp;useSSL=falseusername=rootpassword=root （2）读取 properties 文件，获取属性值 Propertoes 对象获取属性的方法： load()：加载文件流。 getProperties(String name)：根据属性名获取属性值。 123456789// 使用properties文件流获取属性值InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(String filepath);Properties properties = new Properties();// 加载文件流properties.load(in);// 获取properties文件属性值String url = properties.getProperties("url");String username = properties.getProperties("username");String password = properties.getProperties("password"); （3）获取数据库连接 1Connection conn = DriverManager.getConnection(url, username, password); 3.执行SQL语句Statement 执行SQL语句12345// 创建Statement对象执行SQL语句Statement stat = conn.createStatement();String sql = " select * from \"user\" ";// 获取SQL查询结果集ResultSet res = stat.executeQuery(sql); Statement 对象的执行SQL语句方法： boolean execute (String sql)：如果存在结果集，返回 true ；否则返回 false 。 int executeUpdate (String sql)：执行SQL更新语句，返回受影响的行数。 ResultSet executeQuery(String sql)： 执行SQL查询语句，返回查询结果集。 PreparedStatement 预编译为了防止SQL注入，采用 PreparedStatement 预编译SQL语句，使用 ? 作为参数占位符，使用setXXX(int parameterIndex, XXX x) 动态填充参数。 12345678// 预编译String sql = "select * from user where username = ? and password = ? ";PreparedStatement pstat = conn.prepareStatement(sql);// 根据'?'索引填充参数值pstat.setString(1, "admin");pstat.setString(2, "123456");// 获取SQL查询结果集ResultSet res = pstat.executeQuery(sql); setXXX(int paraIndex, XXX x)：根据 ? 参数索引 (1,2,3…) 填充XXX类型的数据。 4.ResultSet 结果集ResultSet：表示数据库结果集的数据表，通常通过执行SQL查询语句生成。 boolean next()：将光标移至下一行。如果没有更多行，返回 false 。 XXX getXXX(String columnName)：返回columnName列中当前行的XXX类型值。 12345678// 迭代保存结果集while(res.next()) &#123; User user = new User(); user.setId(res.getInt("id")); user.setUsername(res.getString("username")); user.setPassword(res.getString("password")); userList.add(user);&#125; 5.释放资源123456// 释放结果集res.close();// 释放statement对象stat.close();// 关闭数据库连接conn.close(); JDBC 事务处理Connection 对象的事务处理方法： setAutoCommit(false)：关闭自动提交 commit()：提交事务 rollback()：回滚事务 setSavepoint(String savepointName)：设置保存点 releaseSavepoint(Savepoint savepointName)：删除保存点 123456789101112try&#123; // 关闭自动提交事务 conn.setAutoCommit(false); ... /* SQL操作 */ ... // If there is no error. conn.commit();&#125;catch(SQLException se)&#123; // If there is any error. conn.rollback();&#125; JDBC 批量处理Statement 对象的批处理方法： void addBatch()：添加SQL语句到批处理中。 int[] executeBatch()： 执行所有SQL语句。返回一个整数数组，数组的每个元素表示相应更新语句的更新计数。 12345678910111213// 1.创建Statement对象Statement stat = conn.createStatement();// 2.关闭自动提交conn.setAutoCommit(false);// 3.添加SQL语句到批处理中String sql = "INSERT INTO Employees (id, first, last, age) " + "VALUES(200,'Ruby', 'Yang', 30)";stat.addBatch(sql);......// 4.执行所有SQL语句，返回更新记数数组int[] count = stat.executeBatch();// 5.提交更新conn.commit(); 数据库连接池数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。 数据库连接提前创建了多个数据库连接，避免在程序运行期间频繁打开/关闭数据库连接造成的性能损耗。这项技术能明显提高对数据库操作的性能。 总而言之，数据库连接是一种昂贵的资源，采用数据库连接池可以控制连接数量，复用连接，提高性能。 常用的数据库连接池 DBCP，Apache 提供的一个Java连接池项目，配置简单，没有连接池监控功能，大并发下速度稍慢。 1BasicDataSource ds = new BasicDataSource(); C3P0，配置简单，没有连接池监控功能，大并发下速度稳定。 1ComboPooledDataSource ds = new ComboPooledDataSource(); Druid，阿里巴巴开源提供的一个数据库连接池实现，在DBCP、C3P0等的基础上添加了日志监控功能。 1DataSource dataSource = DruidDataSourceFactory.createDataSource(); 数据库连接池的使用以DBCP为例，其他大同小异。 前提：安装数据库连接池程序（导入dbcp的jar包） （1）dbcp.properties 1234567891011121314151617181920212223#基本配置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/liziusername=rootpassword=root#初始化池大小initialSize=10#最大连接数maxActive=8#最大空闲连接maxIdle=8#最小空闲连接minIdle=0#最大等待时间maxWait=-1#连接属性connectionProperties=useUnicode=true;characterEncoding=UTF8;useServerPrepStmts=true;cachePrepStmts=true;prepStmtCacheSize=50;prepStmtCacheSqlLimit=300#连接的默认提交方式defaultAutoCommit=true#连接是否为只读连接defaultReadOnly=false#指定事务的事务隔离级别defaultTransactionIsolation=REPEATABLE_READ （2）使用 DataSource 获取数据库连接 12345678910111213// 创建 DataSource 数据源对象BasicDataSource ds = new BasicDataSource();// 设置数据库连接池参数ds.setDriverClassName(properties.getProperty("driverClassName"));ds.setUrl(properties.getProperty("url"));ds.setUsername(properties.getProperty("username"));ds.setPassword(properties.getProperty("password"));ds.setMaxActive(Integer.parseInt(properties.getProperty("maxIdle")));ds.setMaxWait(Long.parseLong(properties.getProperty("maxWait")));ds.setMaxActive(Integer.parseInt(properties.getProperty("maxActive")));ds.setInitialSize(Integer.parseInt(properties.getProperty("initialSize"));// 获取数据库连接Connection conn = ds.getConnection(); DBUtilsCommons DBUtils 是 Apache 提供的一个对 JDBC 进行简单封装的开源工具类库。 DBUtils 组件 QueryRunner：执行SQL语句。 ResultSetHandle：封装结果集的策略对象（将数据存入对象、数组、集合等）。 DBUtils 使用前提：前往 Apache 官网下载安装DBUtils（导入dbutils的jar包）。 QueryRunner 对象执行SQL语句的方法： &lt;T&gt; T query(String sql,ResultSetHandler&lt;T&gt; rsh,Object... params)：执行SQL查询语句，返回结果对象/数组/集合。 int update(String sql,Object...params)：执行SQL更新。 （1）创建 QueryRunner 对象 1QueryRunner qr = new QueryRunner(DataSource ds); （2）执行SQL查询语句（有返回值） 12String sql = "select * from \"product\" where \"proId\" = ?";Product product = qr.query(sql,new BeanHandler&lt;&gt;(Product.class),id); （3）执行SQL更新语句（无返回值） 12String sql = "delete from \"product\" where \"proId\" = ?;qr.update(sql,id);]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle | PL/SQL编程]]></title>
    <url>%2Foracle-plsql.html</url>
    <content type="text"><![CDATA[PL/SQL（Procedural Language/SQL，过程化SQL语言），是一种高级数据库程序设计语言，专门用于在各种环境下对ORACLE数据库进行访问。由于该语言集成于数据库服务器中，所以PL/SQL代码可以对数据进行快速高效的处理。 PL/SQL 中可引用的SQL语句 可用DML语句：SELECT INTO，INSERT，UPDATE，DELETE。 可用TCL语句：COMMIT，ROLLBACK，SAVEPOINT。 不能使用DDL语句。 PL/SQL 块PL/SQL块：声明部分+执行部分+异常处理部分 12345678-- 单行注释DECLARE /* 声明部分：声明变量，类型、游标、局部存储过程和函数 */BEGIN /* 执行部分：执行过程和SQL语句 */[EXCEPTION] /* 异常处理部分 */END; PL/SQL 变量PL/SQL 变量命名 标识符 命名规则 程序变量 V_name 程序常量 C_Name 游标变量 Name_cursor 异常标识 E_name 表类型 Name_table_type 表 Name_table 记录类型 Name_record PL/SQL 变量类型基本数据类型number，char，varchar2，long，date 记录类型记录类型：把逻辑相关的数据作为一个单元存储起来，用于存放互不相同但逻辑相关的信息。 12345TYPE record_type IS RECORD( Field1 type1 [NOT NULL] [:= exp1 ], Field2 type2 [NOT NULL] [:= exp2 ], . . . . . . Fieldn typen [NOT NULL] [:= expn ] ) ; %TYPE 类型%TYPE类型：指某个已定义变量的数据类型类型，或数据表中某列的数据类型。 使用%TYPE特性的优点： 所引用的数据库列的数据类型可以不必知道； 所引用的数据库列的数据类型可以实时改变。 %RowType 类型%RowType类型：返回一个与数据库表的数据结构一致的记录类型。 使用%ROWTYPE特性的优点： 所引用的数据库中列的个数和数据类型可以不必知道； 所引用的数据库中列的个数和数据类型可以实时改变。 PL/SQL 特殊运算符赋值运算符：:=关系运算符：=&gt;上下限运算符：.. PL/SQL 流程控制条件语句IF 语句1234567IF &lt;条件语句1&gt; THEN 语句1;ELSIF &lt;条件语句2&gt; THEN 语句2;ELSE 语句3;END IF; 注意是ELSIF不是ELSEIF； CASE 语句1234567CASE &lt;变量&gt; WHEN &lt;值1&gt; THEN &lt;结果1&gt; WHEN &lt;值2&gt; THEN &lt;结果1&gt; ... WHEN &lt;值N&gt; THEN &lt;结果N&gt; [ELSE &lt;结果N+1&gt;]END; 循环语句do…while 循环1234LOOP 循环语句; EXIT WHEN &lt;条件语句&gt;END LOOP; while 循环123WHILE &lt;条件语句&gt; LOOP 循环语句;END LOOP; for 循环123FOR &lt;循环计数器&gt; IN [REVERSE] &lt;下限&gt; .. &lt;上限&gt; LOOP 循环语句;END LOOP; GOTO 语句定义标号：&lt;&lt;标号名&gt;&gt;； GOTO语句：GOTO 标号名； NULL 语句NULL语句：不做任何事，增强代码可读性。 PL/SQL 异常处理异常错误类型 预定义错误：无需在程序中定义，由Oracle自动将其引发。 非预定义错误：用户需在程序中定义，然后由Oracle自动将其引发。 用户定义错误：用户在程序中定义，然后显式地在程序中将其引发。 异常处理1234EXCEPTION WHEN &lt;异常1&gt; THEN &lt;异常处理代码&gt; WHEN &lt;异常2&gt; THEN &lt;异常处理代码&gt; WHEN OTHERS THEN &lt;异常处理代码&gt; 游标-CURSOR为了处理 SQL 语句，Oracle 会分配一片叫上下文 (context area) 的区域来处理所必需的信息，即系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。游标就是一个指向上下文的句柄或指针。 显式游标显式游标主要是用于对查询语句的处理，尤其是查询结果为多条记录的情况。 显式游标处理：①定义游标：定义游标名及对应的 SELECT 查询 12CURSOR cursor_name (参数1 参数类型,参数2 参数类型...) IS SELECT查询块; 数据类型不能使用长度约束。 ②打开游标：执行游标的 SELECT 查询，将查询结果放入缓冲区，并指向缓冲区首部。 1OPEN cursor_name (参数1 =&gt; 值,参数2 =&gt; 值...); ③提取游标数据：检索结果集中的数据行，放入指定输出变量中。 1FETCH cursor_name INTO &#123;variable_list | record_variable &#125;; ④关闭游标：释放游标占用的系统资源。 1CLOSE cursor_name; 显式游标属性 游标属性 描述 %FOUND 布尔型，当最近一次读记录时成功返回,则值为TRUE %NOTFOUND 布尔型，当最近一次读记录时返回失败,则值为TRUE %ISOPEN 布尔型，当游标已打开时返回 TRUE %ROWCOUNT 数值型，返回已从游标中读取的记录数 游标的FOR循环：123FOR 索引 IN 游标[值1,值2...] LOOP 循环语句;END LOOP; 隐式游标隐式游标主要用于数据更新操作。隐式游标的名字为SQL，由Oracle系统提供，无需用户处理。 隐式游标属性 游标属性 描述 SQL%FOUND 布尔型，当最近一次读记录时成功返回,则值为TRUE SQL%NOTFOUND 布尔型，当最近一次读记录时返回失败,则值为TRUE SQL%ISOPEN 布尔型，当游标已打开时返回 TRUE SQL%ROWCOUNT 数值型，返回已从游标中读取的记录数 存储过程与函数存储过程用于执行特定操作，无返回值；函数用于执行复杂操作，有返回值；存储函数与函数统称为PL/SQL子程序。 存储过程-PROCEDURE存储过程：执行特定操作，无返回值，多用于更新操作。 定义存储过程12345678910CREATE [OR REPLACE] PROCEDURE Procedure_name[ (argment [ &#123; IN | IN OUT &#125;] Type, argment [ &#123; IN | OUT | IN OUT &#125; ] Type ]&#123; IS | AS &#125;&lt;类型.变量的说明&gt; BEGIN &lt;执行部分&gt;EXCEPTION &lt;异常处理&gt;END; 函数-FUNCTION函数：执行复杂操作，有返回值。 定义函数12345678CREATE [OR REPLACE] FUNCTION &lt;函数名&gt;[(argument [ &#123; IN | IN OUT &#125;] type,argument [ &#123; IN | OUT | IN OUT &#125; ] type]RETURN &lt;返回值类型&gt;&#123; IS | AS &#125; &lt;类型.变量的说明&gt; BEGIN &lt;执行部分&gt;EXCEPTION &lt;异常处理&gt;END; 函数执行方式1dbms_output.put_line(fun()); 1select fun() from dual; 函数参数类型 输入参数 IN； 输出参数 OUT； 输入输出参数 IN OUT； 参数传递类型位置表示法：根据参数位置依此传值 1argument_value1[,argument_value2 …] 名称表示法：使用关系运算符=&gt;为参数传值 1argument =&gt; parameter [,…] 触发器-TRIGGER触发器：用户定义的一类由事件触发而执行的特殊过程。 定义触发器12345678CREATE [OR REPLACE] TRIGGER &lt;触发器名称&gt;&#123;BEFORE | AFTER | INSTEAD OF&#125;&#123;INSERT | DELETE | UPDATE [OF column [, column …]]&#125;ON &lt;表/视图&gt;[REFERENCING &#123;OLD [AS] old | NEW [AS] new| PARENT as parent&#125;][FOR EACH ROW | STATEMENT][WHEN condition]trigger_body; 触发事件：INSERT | DELETE | UPDATE 触发时机：BEFORE | AFTER 触发频率： ROW：行级触发；当某触发事件发生时，对受到该操作影响的每一行数据，触发器都单独执行一次。 STATEMENT：语句级触发；当某触发事件发生时，该触发器只执行一次。 触发器的新值与旧值： :new 事件触发后的新的数据行； :old 事件触发前的旧的数据行；]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle | DDL&约束&DCL&TCL]]></title>
    <url>%2Fdb-oracle-ddl.html</url>
    <content type="text"><![CDATA[DDL（Data Definition Language，数据定义语言），用于创建/修改/删除数据库的各种对象，如表、视图、索引、同义词、序列等。DDL语句主要包括 CREATE 创建、ALTER 修改、TRUNCATE 截断 、DROP 删除。 约束CONSTRAINT，用于限制表的数据的类型，主要包括非空约束 NOT NULL、唯一约束 UNIQUE、主键约束 PRIMARY KEY、检查约束 CHECK、外键约束 FOREIGN KEY。 DCL（Data Control Language，数据控制语言），用于授予/回收访问数据库的权限。DCL 语句即GRANT 授予、REVOKE 回收。 TCL（Transaction Control Language，事务控制语言），用于事务的提交/回滚。TCL语句包括 COMMIT 提交、ROLLBACK 回滚，SAVEPOINT 保存点。 Oracle数据库解锁账户1alter user &lt;账户名&gt; account unlock; Oracle 数据类型 NUMBER：整数 DATE：日期 CLOB：大文本数据，可存4G文本数据 BLOB：二进制数据，可存图片、音频、视频、文字，最大4G。 VARCHAR：固定长度字符串，标准sql数据类型 VARCHAR2：可变长度字符串，oracle特有。 字符串：&#39;abc&#39; 字符串连接符：|| 数据伪列 ROWID：数据库中每一行都有一个行地址，rowid伪列返回该行地址。rowId值可以唯一标识数据库中的一行。 ROWNUM：返回一个数值代表行的次序。通过使用rownum，用户可以限制查询返回的行数。 DDL数据定义语言DDL，主要用于创建/修改/删除数据库的各种对象，如表、视图、索引、同义词、序列等。DDL语句主要包括 CREATE 创建、ALTER 修改、DROP 删除。 表：TABLE创建表123456CREATE TABLE &lt;表名&gt;( &lt;列名&gt; &lt;数据类型&gt; [&lt;DEFAULT 默认值&gt;] [&lt;约束&gt;], &lt;列名&gt; &lt;数据类型&gt; [&lt;DEFAULT 默认值&gt;] [&lt;约束&gt;], ... [CONSTRAINT &lt;约束名&gt; &lt;约束类型&gt;(约束列)]) 修改表修改表中列 1.增加列： 12345ALTER TABLE &lt;表名&gt; ADD （ &lt;列名&gt; &lt;数据类型&gt; [&lt;DEFAULT 默认值&gt;] [&lt;列级约束&gt;], &lt;列名&gt; &lt;数据类型&gt; [&lt;DEFAULT 默认值&gt;] [&lt;列级约束&gt;], ...) 2.修改列： 12345ALTER TABLE &lt;表名&gt; MODIFY （ &lt;列名&gt; &lt;数据类型&gt; [&lt;DEFAULT 默认值&gt;] [&lt;列级约束&gt;], &lt;列名&gt; &lt;数据类型&gt; [&lt;DEFAULT 默认值&gt;] [&lt;列级约束&gt;], ...) 3.删除列： 1ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt; 4.重命名列： 1ALTER TABLE &lt;表名&gt; RENAME &lt;旧名&gt; TO &lt;新名&gt; 修改表中属性： 1.添加约束： 1ALTER TABLE &lt;表名&gt; ADD CONSTRAINT &lt;约束名&gt; &lt;约束类型&gt;(约束列); 2.删除约束： 1ALTER TABLE &lt;表名&gt; DROP CONSTRAINT &lt;约束名&gt;; 截断表1TRUNCATE TABLE &lt;表名&gt; 删除表1.删除表： 1DROP TABLE &lt;表名&gt; 2.截断表： 复制表1.复制表的结构与数据： 1234CREATE TABLE &lt;表名&gt; AS SELECT &lt;目标列表达式&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt; 2.仅复制表的结构：WHERE 1 = 2 1234CREATE TABLE &lt;表名&gt; AS SELECT &lt;目标列表达式&gt; FROM &lt;表&gt; WHERE 1 = 2; 重命名1RENAME &lt;旧名称&gt; TO &lt;新名称&gt; 视图：VIEW视图 (VIEW)：虚拟表，不占物理空间。 创建视图123456CREATE [OR REPLACE] [FORCE] VIEW &lt;视图名&gt;[(列名1, 列2,...)]AS SELECT...[WITH CHECK OPTION][WITH READ ONLY]; FORCE：强制创建视图WITH CHECK OPTION：检查约束视图WITH READ ONLY：只读视图 删除视图1DROP VIEW &lt;视图名&gt; 索引：INDEX索引：加快查询速度 创建索引12345678CREATE [UNIQUE] INDEX &lt;索引名&gt;ON &lt;表名&gt; (&lt;列名&gt; [ASC | DESC], ... )[INITRANS n][MAXTRANS n][PCTFREE n][TABLESPACE &lt;表空间名&gt;][STORAGE storage][NOSORT] UNIQUE：唯一索引INITRANS：初始事务入口数MAXTRANS：最大事务入口数PCTFREE：索引数据块空闲空间的百分比NOSORT：不排序 ###修改索引 重建索引 1ALTER INDEX &lt;索引名&gt; REBUILD; 合并索引 1ALTER INDEX &lt;索引名&gt; COALESCE; 删除索引1DROP INDEX &lt;索引名&gt; 同义词：SYNONYM同义词：数据库对象的一个别名，操作权限不变，简化对象访问。 创建同义词12CREATE [PUBLIC] SYNONYM &lt;表名同义词&gt;FOR &lt;用户&gt;.&lt;表名&gt; 删除同义词1DROP [PUBLIC] SYNONYM &lt;同义词&gt; 序列：SEQUENCE序列 (SEQUENCE)： 序列号生成器，为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。不占用磁盘空间，占用内存。 其主要用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。 创建序列1234567CREATE SEQUENCE &lt;序列名&gt;[INCREMENT BY n][START WITH n][MAXVALUE n | NOMAXVALUE][MINVALUE n | NOMINVALUE][CYCLE | NOCYCLE][CACHE n | NOCACHE]; INCREMENT BY：定义步长START WITH：定义序列初始值MAXVALUE / MINVALUE：定义序列最大值/最小值NOMAXVALUE：默认最值CYCLE / NOCYCLE：表示序列达到限定值后是否循环CACHE n：对序列进行内存缓冲，提前生成n个序号存入缓存，默认n=20NOCACHE：不对序列进行内存缓冲 序列的两个伪列 NEXTVAL：序列中的下一个有效值 CURRVAL：序列当前值 修改序列1234567ALTER SEQUENCE [&lt;用户&gt;.]&lt;序列名&gt;[INCREMENT BY n][START WITH n][MAXVALUE n | NOMAXVALUE][MINVALUE n | NOMINVALUE][CYCLE | NOCYCLE][CACHE n | NOCACHE]; 删除序列1DROP SEQUENCE &lt;序列名&gt; 约束-CONSTRAINT约束CONSTRAINT，用于限制表的数据的类型。 1CONSTRAINT &lt;约束名&gt; &lt;约束类型&gt;(约束列) 非空约束：NOT NULL非空约束：NOT NULL 1&lt;列名&gt; &lt;数据类型&gt; NOT NULL 唯一约束：UNIQUE唯一约束：UNIQUE 1&lt;列名&gt; &lt;数据类型&gt; UNIQUE 1CONSTRAINT uk_cloumn UNIQUE(&lt;列名&gt;); 主键约束：PRIMARY KEY主键约束：PRIMARY KEY，非空+唯一 1CONSTRAINT pk_cloumn PRIMARY KEY(&lt;列名&gt;); 联合主键： 1CONSTRAINT pk_cloumn PRIMARY KEY(&lt;列名1&gt;,&lt;列名2&gt;,...); 检查约束：CHECK1CONSTRAINT ck_cloumn CHECK(&lt;列名&gt; IN (值1,值2...)) 1CONSTRAINT ck_cloumn CHECK(&lt;列名&gt; BETWEEN 值1 AND 值2) 外键约束：FOREIGN KEY1CONSTRAINT fk_cloumn FOREIGN KEY (&lt;列名1&gt;,&lt;列名2&gt;...) REFERENCES &lt;表名&gt;(&lt;列名1&gt;,&lt;列名2&gt;...) ON DELETE &lt;CASCADE|SET NULL&gt; 数据库安全-DCL数据控制语言DCL，用于授予/回收用户/角色访问数据库的权限，DCL语句即 GRANT 授予、REVOKE 回收。 授予权限：GRANT1234GRANT &lt;权限&gt;ON &lt;对象类型&gt; &lt;对象名&gt;TO &lt;用户&gt;[WITH GRANT OPTION] WITH GRANT OPTION：可传播权限，即将该权限再授予其他用户。 收回权限：REVOKE123REVOKE &lt;权限&gt;ON &lt;对象类型&gt; &lt;对象名&gt;FROM &lt;用户&gt; [CASCADE|RESTRICT] CASCADE：级联RESTRICT：限定 角色：ROLE角色(ROLE)：一组数据库操作权限的集合。 1.创建角色： 1CREATE ROLE &lt;角色名&gt; 2.为角色授权： 123GRANT &lt;权限&gt;ON &lt;对象类型&gt; &lt;对象名&gt;TO &lt;角色&gt; 3.将角色授权给其他角色或用户： 123GRANT &lt;角色1&gt;ON &lt;对象类型&gt; &lt;对象名&gt;TO &lt;角色2&gt;,&lt;用户&gt; 事务-TCL事务：用于保证数据完整性。由一组DML语句组成，这组DML语句要么全部成功，要么全部失败。 事务特性：ACID 原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 事务锁事务并发不一致性导致的问题： 幻读：事务T1读取一条指定where条件的语句，返回结果集。此时事务T2插入一行新记录并commit，恰好满足T1的where条件。然后T1使用相同的条件再次查询，结果集中可以看到T2插入的记录，这条新纪录就是幻想。 不可重复读取：事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录并commit，然后T1再次查询，发现与第一次读取的记录不同，这称为不可重复读。 脏读：事务T1更新了一行记录，还未提交所做的修改，这个T2读取了更新后的数据，然后T1执行回滚操作，取消刚才的修改，所以T2所读取的行就无效，也就是脏数据。 –于是引入事务锁，以保证数据的完整性。 四种隔离级别： 串行化 可重复读 读已提交 读未提交 事务处理-TCL事务控制语言TCL，用于事务的提交/回滚。TCL语句即 COMMIT 提交、ROLLBACK 回滚，SAVEPOINT 保存点。 提交：COMMIT事务提交 COMMIT：将事务中对数据库的修改进行永久保存。 显式提交：需要主动提交SQL语句对于数据库的修改，未提交之前可以rollback。如DML操作。 隐式提交：SQL语句执行结束自动提交，无法rollback。如DDL，DCL。 回滚：ROLLBACK回滚 ROLLBACK：取消事务中对数据库进行的修改。 保存点：SAVEPOINT1savepoint &lt;savepoint_name&gt; 回滚至保存点1rollback to savepoint &lt;savepoint_name&gt; 数据库设计范式实际设计原则：根据业务尽可能的减少多表查询，不必完全遵循设计范式。 第一范式：确保表中每个字段都不可拆分。 第二范式：消除了部分函数依赖；确保表中每列都与主键相关（主要针对联合主键）。 第三范式：消除了传递函数依赖；确保每列与主键直接相关，而不是间接相关。]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Database | DQL&DML]]></title>
    <url>%2Fdb-dml.html</url>
    <content type="text"><![CDATA[SQL（Structured Query Language，结构化查询语言），面向集合的描述性非过程化语言，用于访问和处理关系数据库的标准语言。SQL 是一种 ANSI 标准，所以存在多种不同版本的 SQL 语言。但就 SQL 查询和更新而言，Oracle、MySql 等数据库系统的实现大同小异，基本可以互通移植。 DQL（Data Query Language，数据查询语言），即 SQL 查询，DQL 语句即 SELECT 查询块。 DML（Data Manipulation Language，数据操作语言），即 SQL 更新，DML 语句即 INSERT 插入、UPDATE 更新、DELETE 删除。 1. SQL查询★SELECT 语句的一般格式： 12345SELECT [DISTINCT] &lt;目标列表达式&gt; [AS] &lt;别名&gt;FROM &lt;表/视图&gt; [AS] &lt;别名&gt;[WHERE &lt;查询条件&gt;][GROUP BY &lt;分组列&gt; [HAVING &lt;分组条件&gt;]][ORDER BY &lt;排序列&gt; [ASC|DESC]]; 1.1 单表查询1.1.1 简单查询：SELECT12SELECT [DISTINCT] &lt;目标列表达式&gt; [AS] &lt;别名&gt;FROM &lt;表/视图&gt; [AS] &lt;别名&gt; 1.查询全部列：使用通配符*实现查询全部。 12SELECT *FROM &lt;表/视图&gt; 2.去除重复行：DISTINCT 12SELECT DISTINCT &lt;目标列&gt;FROM &lt;表/视图&gt; 3.指定别名（Alias）： 12&lt;列名/表名&gt; &lt;别名&gt;&lt;列名/表名&gt; AS &lt;别名&gt; 1.1.2 查询条件：WHERE123SELECT &lt;目标列表达式&gt; [AS] &lt;别名&gt;FROM &lt;表/视图&gt; [AS] &lt;别名&gt;WHERE &lt;查询条件&gt; 查询条件： 1.比较运算：&gt;，&lt;，=，&gt;=，&lt;=，!=/&lt;&gt; 2.确定范围：BETWEEN...AND... 1&lt;列名&gt; [NOT] BETWEEN &lt;下限&gt; AND &lt;上限&gt; 3.确定集合：IN 1&lt;列名&gt; [NOT] IN （值1, 值2...） 4.模式匹配：LIKE 1&lt;列名&gt; [NOT] LIKE '&lt;匹配模式&gt;' 通配符 描述 % 替代一个或多个字符 _ 替代一个字符 [charlist] 字符序列中的任何单一字符 [!charlist][^charlist] 不在字符序列中的任何单一字符 5.空值：IS NULL 1&lt;列名&gt; IS [NOT] NULL 6.多重条件（逻辑运算）：AND，OR，NOT 123&lt;条件表达式&gt; AND &lt;条件表达式&gt;&lt;条件表达式&gt; OR &lt;条件表达式&gt;NOT &lt;条件表达式&gt; AND优先级&gt;OR优先级 1.1.3 查询排序：ORDER BYORDER BY 子句将查询结果按指定列进行升序 (ASC) 或降序 (DESC) 排序。 1ORDER BY &lt;排序列&gt; [ASC|DESC] ORDER BY 子句只能对最终查询结果排序。不能对内层查询使用。 1.1.4 聚集函数 聚集函数 描述 COUNT(*) 统计记录行数 COUNT([DISTINCT]&lt;列名&gt;) 统计列中值个数 SUM([DISTINCT]&lt;列名&gt;) 计算列值总和 AVG([DISTINCT]&lt;列名&gt;) 计算列值平均值 MAX([DISTINCT]&lt;列名&gt;) 求列值最大值 MIN([DISTINCT]&lt;列名&gt;) 求列值最小值 注意：①只有COUNT(*)计算空值，其余聚集函数都跳过空值。②WHERE 子句中不能用聚集函数，聚集函数只能用于 SELECT 子句和 GROUP BY 中的 HAVING 子句。 1.1.5 分组查询：GROUP BYGROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组。 1GROUP BY &lt;分组列&gt; HAVING &lt;分组条件&gt; 分组的目的是为了细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，即每一组都有一个聚集函数值。 WHERE 子句与 HAVING 子句区别：①WHERE 子句作用于基本表/视图，不能使用聚集函数。②HAVING 子句作用于组。 1.2 连接查询连接查询：使用连接运算符实现多表查询 1.2.1 交叉连接交叉连接：笛卡儿积。 ①隐式连接： 12SELECT &lt;目标列&gt;FROM &lt;表1&gt;, &lt;表2&gt; ②使用 JOIN 连接： 12SELECT &lt;目标列&gt;FROM &lt;表1&gt; CROSS JOIN &lt;表2&gt; 消除笛卡尔积：使用关联字段。 1.2.2 内连接内连接：查询与连接条件匹配的所有行，但不去除重复属性列。 ①隐式连接： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt;, &lt;表2&gt;WHERE &lt;表1&gt;.&lt;关联属性&gt; &lt;比较运算符&gt; &lt;表2&gt;.&lt;关联属性&gt; ②使用 JOIN 连接： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; [INNER] JOIN &lt;表2&gt; ON &lt;表1&gt;.&lt;关联属性&gt; &lt;比较运算符&gt; &lt;表2&gt;.&lt;关联属性&gt; 1.等值连接 等值连接：当比较运算符为=时的内连接，不去除重复属性列。 ①隐式连接： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt;, &lt;表2&gt;WHERE &lt;表1&gt;.&lt;关联属性&gt; = &lt;表2&gt;.&lt;关联属性&gt; ②使用 JOIN 连接： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; [INNER] JOIN &lt;表2&gt; ON &lt;表1&gt;.&lt;关联属性&gt; = &lt;表2&gt;.&lt;关联属性&gt; 2.非等值连接 非等值连接：当比较运算符不为=时的内连接，不去除重复属性列。 ①隐式连接： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt;, &lt;表2&gt;WHERE &lt;表1&gt;.&lt;关联属性&gt; &lt;比较运算符&gt; &lt;表2&gt;.&lt;关联属性&gt; ②使用 JOIN 连接： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; [INNER] JOIN &lt;表2&gt; ON &lt;表1&gt;.&lt;关联属性&gt; &lt;比较运算符&gt; &lt;表2&gt;.&lt;关联属性&gt; 3.自身连接 自身连接：一个表与其自身进行等值连接。 ①隐式连接： 123SELECT &lt;目标列&gt;FROM &lt;表&gt; FIR, &lt;表2&gt; SECWHERE FIR.&lt;关联属性&gt; = SEC.&lt;关联属性&gt; ②使用 JOIN 连接： 123SELECT &lt;目标列&gt;FROM &lt;表&gt; FIR [INNER] JOIN &lt;表2&gt; SECON FIR.&lt;关联属性&gt; = SEC.&lt;关联属性&gt; 4.自然连接 自然连接：去除重复属性列的等值连接，消除了笛卡儿积。 12SELECT *FROM &lt;表1&gt; NATURAL JOIN &lt;表2&gt; 1.2.3 外连接外连接：主表内容全部显示。未匹配到，用NULL填充。 1.左外连接 左外连接：以左表为主表，右表为从表。即使右表中没有匹配，也返回左表所有行。 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; LEFT [OUTER] JOIN &lt;表2&gt;ON &lt;表1&gt;.&lt;关联属性&gt; = &lt;表2&gt;.&lt;关联属性&gt; Oracle特有写法：从表以 (+) 表示。 123SELECT &lt;目标列&gt;FROM &lt;表1&gt;, &lt;表2&gt;WHERE &lt;表1&gt;.&lt;关联属性&gt; = &lt;表2&gt;.&lt;关联属性&gt;(+) 2.右外连接 右外连接：以右表为主表，左表为从表。即使左表中没有匹配，也返回右表所有行。 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; RIGHT [OUTER] JOIN &lt;表2&gt;ON &lt;表1&gt;.&lt;关联属性&gt; = &lt;表2&gt;.&lt;关联属性&gt; Oracle特有写法：从表以 (+) 表示。 123SELECT &lt;目标列&gt;FROM &lt;表1&gt;, &lt;表2&gt;WHERE &lt;表1&gt;.&lt;关联属性&gt;(+) = &lt;表2&gt;.&lt;关联属性&gt; 3.全外连接 全外连接：返回左表和右表中的所有数据。未匹配字段显示为NULL。 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; FULL [OUTER] JOIN &lt;表2&gt;ON &lt;表1&gt;.&lt;关联属性&gt; = &lt;表2&gt;.&lt;关联属性&gt; 1.2.4 指定关联字段①隐式连接-使用WHERE子句指定关联字段： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt;, &lt;表2&gt;WHERE &lt;表1&gt;.&lt;关联属性&gt; &lt;比较运算符&gt; &lt;表2&gt;.&lt;关联属性&gt; ②JOIN连接-使用ON指定关联字段： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; JOIN &lt;表2&gt; ON &lt;表1&gt;.&lt;关联属性&gt; &lt;比较运算符&gt; &lt;表2&gt;.&lt;关联属性&gt; ③JOIN连接-使用USING指定关联字段： 123SELECT &lt;目标列&gt;FROM &lt;表1&gt; JOIN &lt;表2&gt; USING (&lt;关联属性&gt;) USING等价于ON指定等值同名的关联字段。 1.3 子查询查询块：临时表 123SELECT &lt;目标列&gt;FROM &lt;表&gt;WHERE &lt;查询条件&gt; 1.3.1 嵌套查询嵌套查询：将一个查询块嵌套在另一个查询块的WHERE/HAVING条件子句中。 123456SELECT &lt;目标列&gt;FROM &lt;表&gt;WHERE &lt;列名&gt; &lt;运算符/谓词&gt; (SELECT &lt;目标列&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt;) 1.带有比较运算符的子查询 当子查询返回单值时，可以使用比较运算符连接。 123456SELECT &lt;目标列&gt;FROM &lt;表&gt;WHERE &lt;列名&gt; &lt;比较运算符&gt; (SELECT &lt;目标列&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt;) 比较运算符：&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，= 2.带有IN的子查询 当子查询返回一个集合时，一般使用IN进行连接。IN在嵌套查询中最为常用。 123456SELECT &lt;目标列&gt;FROM &lt;表&gt;WHERE &lt;列名&gt; IN (SELECT &lt;目标列&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt;) 3.带有ANY或ALL的子查询 123456SELECT &lt;目标列&gt;FROM &lt;表&gt;WHERE &lt;列名&gt; &lt;比较运算符&gt;ANY (SELECT &lt;目标列表达式&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt;) &lt;比较运算符&gt;ALL：与子查询结果的所有值进行比较运算。&lt;比较运算符&gt;ANY：与子查询结果的任意某个值进行比较运算。 1.3.2 派生查询派生查询：将一个查询块嵌套在另一个查询块的FROM子句中，子查询生成的派生表成为了主查询的查询对象。 123SELECT &lt;目标列&gt;FROM &lt;表&gt;, (SELECT &lt;目标列&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt;) [AS] &lt;别名&gt;WHERE &lt;查询条件&gt; 注意：必须为子查询生成的派生表指定别名。 1.4 集合查询集合查询：多个查询结果进行集合运算。 123SELECT &lt;目标列&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt; &lt;集合运算谓词&gt;SELECT &lt;目标列&gt; FROM &lt;表&gt; WHERE &lt;查询条件&gt; 注意：参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同。 集合运算 谓词 并集（去重复） UNION 并集（不去重复） UNION ALL 交集 INTERSECT 差集 MINUS 2. SQL更新2.1 SQL插入：INSERT1INSERT INTO &lt;表&gt; (列名, 列名...) VALUES(值, 值...) INSERT简写-按表的列顺序插入一行数据： 1INSERT INTO &lt;表&gt; VALUES(值, 值...) 2.2 SQL修改：UPDATE12UPDATE &lt;表&gt; SET 列名 = 值, 列名 = 值... [WHERE &lt;修改条件&gt;] 2.3 SQL删除：DELETE12DELETE FROM &lt;表&gt; [WHERE &lt;删除条件&gt;]]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2Fmarkdown-grammer.html</url>
    <content type="text"><![CDATA[Markdown是一种简单的、用于文本排版的轻量级标记语言，它使用简洁的语法代替排版，让作者更专注于作品的内容。并且允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的HTML文档，非常适用于网络书写。 标题123456# 一级标题 h1## 二级标题 h2### 三级标题 h3#### 四级标题 h4##### 五级标题 h5###### 六级标题 h6 效果： 一级标题 h1二级标题 h2三级标题 h3四级标题 h4五级标题 h5六级标题 h6加粗1**Bold** 1__Bold__ 效果： Blod 斜体1*italic* 1_italic_ 效果： italic 删除线1~~delete~~ 效果： delete 分割线1*** 1--- 效果： 引用1&gt; 引用 示例： 1234&gt; 谁家玉笛暗飞声，&gt; 散入春风满洛城。&gt; 此夜曲中闻折柳，&gt; 何人不起故园情。 效果： 谁家玉笛暗飞声，散入春风满洛城。此夜曲中闻折柳，何人不起故园情。 代码1`code` 示例： 1`&lt;br/&gt;` 效果： &lt;br/&gt; 代码块 ```typecodeblock``` 示例： ```javapublic class HelloWorld {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“HelloWorld”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}``` 效果： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; 图片1![Alt](http://) 示例： 1![示例图片](http://p6uturdzt.bkt.clouddn.com/markdown-logo.jpg) 效果： 链接1[Link](http://) 示例： 1[百度](http://www.baidu.com) 效果： 百度 无序列表123- Red- Green- Blue 123+ Red+ Green+ Blue 123* Red* Green* Blue 效果： Red Green Blue 有序列表1231. Red2. Green3. Blue 效果： Red Green Blue 表格1234| 列名 | 列名 || ---- | ---- || 表项 | 表项 || 表项 | 表项 | 效果： 列名 列名 表项 表项 表项 表项 空格12&amp;nbsp; //半角空格（英文）&amp;emsp; //全角空格（中文） 居中1&lt;center&gt;居中文本&lt;/center&gt; 换行1&lt;br/&gt; 锚-页内跳转123[跳转到锚点](#jump)......&lt;span id = "jump"&gt;锚点&lt;/span&gt; 示例： 12345678目录[1.Java入门](#1)[2.Java基础](#2)正文&lt;span id = 1&gt;1.Java入门&lt;/span&gt;some_text......&lt;span id = 2&gt;2.Java基础&lt;/span&gt;some_text...... 效果： 目录 1.Java入门 2.Java基础 正文 1.Java入门 some_text…… 2.Java基础 some_text……]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git | QuickStart]]></title>
    <url>%2Fgit-quickstart.html</url>
    <content type="text"><![CDATA[Git 是目前世界上最流行的分布式版本控制系统。它速度快，简单，采用完全分布式，可高效管理代码，对非线性开发模式提供强力支持。 Git 诞生于一个极富纷争的年代。起因是 Linus 创建了开源的 Linux，在 2002 年以前，Linux 的内核维护工作主要是由世界各地的志愿者将源码文件通过 diff 方式发给 Linus，然后由Linus本人手工合并代码。到了 2002 年，Linux 代码库之大已经很难通过手工方式管理，于是 Linus 选择了分布式版本控制系统 BitKeeper 管理和维护代码。2005 年，BitKeeper 与 Linux开源社区的合作关系结束，迫使 Linux 开源社区不得不开发一套属于自己的版本控制系统。于是，Linus 花了两周时间用 C 写了一个分布式版本控制系统Git，一个月之内 Linux 源码已经由 Git 进行管理了。 0. Git 基本操作0.1 创建一个新的仓库12345$ git init$ git add .$ git commit -m "initial commit"$ git remote add origin &lt;url&gt;$ git push origin master 0.2 记录每次更新到远程仓库123$ git add .$ git commit -m "initial commit"$ git push origin master 1. Git 配置1.1 配置用户信息1234# git配置用户名$ git config --global user.name "username"# git配置用户邮箱$ git config --global user.email useremail@example.com 1.1 查看配置信息1$ git config --list 2. Git 本地仓库2.1 创建本地仓库12# git初始化本地仓库$ git init 将当前所在目录初始化为一个本地仓库。初始化完成后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中，切记不要手动修改该目录下的任何文件。 2.2 克隆远程仓库到本地1234# 克隆远程仓库的默认分支$ git clone &lt;url&gt;# 克隆远程仓库的指定分支$ git clone -b &lt;branch-name&gt; &lt;url&gt; git支持多种数据传输协议： ssh协议：user@server:/path.git https协议： http(s):// git协议： git:// 3. Git 版本控制git 工作流程： 3.1 查看文件状态12# 查看仓库文件状态$ git status git 文件状态变化： 3.2 暂存修改git add ：①跟踪未跟踪文件，②将已跟踪文件放入暂存区。 1234# 跟踪所有文件，暂存所有修改$ git add .# 跟踪某个文件，暂存某个文件修改$ git add &lt;file-name&gt; 3.3 撤销文件修改12# 撤销文件修改$ git checkout --&lt;file&gt; 3.4 提交更新git commit ：将本次更新全部提交到本地仓库。 1234# 提交已暂存更新$ git commit -m "提交说明"# 暂存并提交更新$ git commit -am "提交说明" 3.5 查看提交日志12# 查看提交日志$ git log 3.6 版本回退1. 软回退：只回退commit信息。 1$ git reset --soft HEAD^ 2. 默认回退：回退commit和index信息，只保留本地源码。 1$ git reset --mixed HEAD^ 3. 硬回退：commit、index信息、本地源码全部回退。 1$ git reset --hard HEAD^ 版本的表示方式： HEAD^ 上一版本，HEAD^^ 上上个版本 …… HEAD~n：上n个版本 &lt;commit_id&gt;：某个指定版本 4. Git 远程仓库4.1 添加远程仓库12# 添加一个远程仓库$ git remote add &lt;remote-name&gt; &lt;url&gt; 4.2 移除远程仓库12# 移除某个远程仓库$ git remote rm &lt;remote-name&gt; 4.3 重命名远程仓库12# 重命名远程仓库$ git remote rename &lt;old-name&gt; &lt;new-name&gt; 4.4 查看远程仓库12# 查看所有远程仓库$ git remote -v 4.5 从远程仓库抓取数据12# 从远程仓库抓取数据$ git fetch &lt;remote-name&gt; 4.6 推送数据到远程仓库12# 推送数据到远程仓库$ git push &lt;remote-name&gt; &lt;branch-name&gt; 5. Git 分支Git 分支原理：每一个分支存在一个分支指针，分支指针指向不同版本；Git 分支切换：HEAD 指针指向某个分支指针； 5.1 创建分支12# 创建一个分支$ git branch &lt;branch-name&gt; 5.2 切换分支1234# 切换分支$ git checked &lt;branch-name&gt;# 创建并切换到该分支$ git checked -b &lt;branch-name&gt; 5.3 合并分支12# 合并分支$ git merge &lt;other-branch&gt; 5.4 删除分支12# 删除分支$ git branch -d &lt;branch-name&gt; 5.5 查看分支12# 查看所有分支$ git branch -v 6. GitHub ForkFork即派生项目。在GitHub社区中可以Fork任意开源仓库。Fork之后，GitHub 将在你的空间中创建一个项目副本，你对项目副本拥有读写权限。并且可以推送pull request给官方仓库贡献代码。 Fork 流程： 从 master 分支中创建一个新分支 提交一些修改到新分支来改进项目 将这个分支推送到 GitHub 上 创建一个合并请求(Pull Request) 项目的拥有者合并或关闭你的合并请求 7. gitignore.gitignore文件规范： #：注释 !：取反 *：任意长度字符 ?：匹配单个字符 [abc]：匹配方括号中的任意单个字符 [0-9]：匹配两个字符之间的任意字符 **：匹配任意中间目录 以/开头防止递归 以/结尾指定目录 参考资料：GitBook；]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo | （四）多机同步更新博客]]></title>
    <url>%2Fhexo-multimachine.html</url>
    <content type="text"><![CDATA[Hexo博客存在一个问题：我们仅仅将博客的静态页面文件部署到了github远程仓库中，而我们的站点源文件仍在本地存储。如果存储站点源文件的电脑系统崩溃了，或者我们换了其他电脑，我们便无法实时更新博客了。如果选择重新搭建站点，不仅过程繁琐，而且还需要大量时间安装依赖、主题配置、博客优化，极其麻烦。所以我们需要将站点必要文件也部署到github远程仓库中。我们采取的远程仓库部署策略是：一个仓库两个分支。仓库即[yourname.github.io]，一个分支[master]用于托管演示页面，一个分支[backup]用于备份Hexo博客站点的必要文件。 多机同步更新的前提：backup分支Hexo博客站点的必要文件： 12345678.├── scaffolds # 文章模板├── source # 用户源文件：页面，文章markdown文件├── themes # 主题├── .gitignore # git忽略文件信息├── _config.yml # 站点配置文件├── package.json # 已安装插件映射表，下次只需npm install即直接安装表中的插件├── package-lock.json 编辑站点根目录下的.gitignore文件，使Git上传时忽略不必要的文件： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 1.删除themes\你的主题中的.git，.github，.gitignore等git仓库文件，只保留站点根目录下的.gitignore。 2.在Hexo博客站点根目录（即blog文件夹）中GitBash： 123456789101112# 将blog作为一个git仓库进行初始化$ git init # 创建/切换hexo分支$ git checkout -b backup # 将文件添加到暂存区$ git add . # 将暂存区文件提交到本地仓库$ git commit -m "提交说明" # 添加远程仓库$ git remote add origin https://github.com/yourname/yourname.github.io.git# 将本地仓库推送至远程仓库$ git push origin backup 多机同步更新博客1.安装前提(1) 安装Git(2) 安装nodejs 2.博客还原12345678910# 克隆hexo分支到本地$ git clone -b backup https://github.com/yourname/yourname.github.io.git# 进入yourname.github.io文件夹$ cd yourname.github.io# 安装hexo$ npm install hexo --save# 安装hexo命令行模式$ npm install hexo-cli -g# 安装所有依赖，根据package.json自动安装之前安装过的插件$ npm install 3.配置网络协议(1) SSH协议，长期部署推荐SSH，一劳永逸。 ①SSH秘钥： 123456# 生成rsa秘钥$ ssh-keygen -t rsa -C "youremail@example.com"# 进入虚拟目录ssh文件中$ cd ~/.ssh# 显示id_rsa.pub文件内容$ cat id_rsa.pub ②复制秘钥至github/coding-&gt;用户setting-&gt;SSH keys，New SSH Key； ③验证是否添加成功 12$ ssh -T git@github.com # 验证github是否添加成功$ ssh -T git@coding.net # 验证coding是否添加成功 ④编辑站点配置文件_config.yml： 123456deploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git coding: git@git.coding.net:yourname/yourname.coding.me.git branch: master ⑤添加远程仓库 1$ git remote add origin git@github.com:yourname/yourname.github.io.git (2) HTTPS协议，临时部署推荐HTTPS。 ①直接编辑站点配置文件_config.yml： 123456deploy: type: git repo: github: https://github.com/yourname/yourname.github.io.git coding: https://git.coding.net/yourname/yourname.coding.me.git branch: master ②验证github/coding用户名和密码。 ③添加远程仓库 1$ git remote add origin https://github.com/yourname/yourname.github.io.git 4.正常使用重新部署： 12$ hexo clean$ hexo g -d 上传至hexo分支： 123$ git add .$ git commit -m "commit-message"$ git push origin backup]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo | （三）URL优化&站点提交]]></title>
    <url>%2Fhexo-submit.html</url>
    <content type="text"><![CDATA[在站点搭建完成之后，搜索引擎是无法搜索到我们自己的网站的。如果想要在搜索引擎中搜索到自己的博客，我们就需要将自己的站点提交给搜索引擎。在站点提交之前，为了方便搜索引擎的爬虫爬取网页，我们需要先优化一下自己网站的URL。 URL优化一个好的URL设计，不仅有利于网络爬虫的爬取，更有利于用户的体验。 正确的URL设计应该满足：长度尽量短，目录层次尽量少，全小写，连字符使用中划线-，具有描述性，包含关键词等。 文章URL优化文章URL优化策略（一）：自定义id属性 1.为每篇文章Front-matter添加id属性，作为文章URL，确保id属性的值满足以上条件。 2.编辑站点配置文件： 12# permalink: :year/:month/:day/:title.html # 默认永久链接冗长，title中存在中文字符。permalink: :id.html # 尽量短，层次少，全小写，中划线连字，具有描述性，包含关键词 文章URL优化策略（二）：abbrlink链接唯一化 1.安装abbrlink插件： 1$ npm install hexo-abbrlink --save 2.编辑站点配置文件： 1234permalink: :abbrlink.html # 生成唯一链接abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 标签&amp;分类URL优化我们在对文章分类或添加标签时，难免会用到中文或其他字符，而我们又在尽量避免中文字符出现在URL中，所以我们需要对中文分类&amp;标签进行映射操作。 编辑站点配置文件： 12345678# 分类名映射category_map: 生活: life 其他: other# 标签名映射tag_map: 生活: life 其他: other 站点提交谷歌站点提交谷歌搜索将您的网址添加到 Google 索引中，键入网址，提交请求即可。 验证是否被谷歌收录：site:example.com； 百度站点提交1.验证是否被百度收录打开百度，输入site:&lt;域名&gt;，验证是否被百度收录。 1site:example.com 2.链接提交若未被收录，点击“提交网址”。登录百度站长平台，链接提交，输入&lt;域名&gt;。注意：不要输入github.io的域名，github不允许百度爬虫爬取。 3.验证网站所有权验证方式有三种：文件验证、HTML标签验证和CNAME验证，任选一种验证成功即可。 (1)文件验证：下载验证文件 (一个存放着token信息的html文件) ，将验证文件置于网站根目录下（blog/source/或者theme/next/）。 (2)HTML标签验证：将以下代码添加到你的网站首页HTML代码的&lt;head&gt;&lt;/head&gt;中 1&lt;mate name="baidu-site-verification" content="你的token"&gt; (3)CNAME验证：如果你绑定了自己的域名，只需添加一条CNAME域名解析记录： 记录类型 主机记录 记录值 CNAME 你的token ziyuan.baidu.com 推荐使用CNAME验证或文件验证。 为使您的网站一直保持验证通过的状态，请保留验证的文件、html标签或CNAME记录，百度可能会去定期检查验证记录。 4.生成网站地图编辑站点配置文件，确保url是你的域名地址： 1url: https://&lt;你的域名&gt; 安装sitemap插件： 123$ npm install hexo-generator-sitemap --save # 安装谷歌站点地图插件$ npm install hexo-generator-baidu-sitemap --save # 安装百度站点地图插件$ hexo g # 生成sitemap.xml和baidusitemap.xml 5.链接提交 如何选择链接提交方式？①主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。②自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。③sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。④手动提交：一次性提交链接给百度，可以使用此种方式。 效率：主动推送&gt;自动推送&gt;sitemap 使用submit插件实现主动推送： 1.安装百度提交插件： 1$ npm install hexo-baidu-url-submit --save 2.编辑站点配置文件，配置以下信息： 12345baidu_url_submit: count: 3 # 提交最新链接数 host: &lt;域名&gt; # 你所提交的域名 token: yourtoken # 秘钥，请不要发布在公众仓库中 path: baidu_urls.txt # 文本文档路径，新链接会保存在此文本文档中 3.编辑站点配置文件，为deploy新增一个type： 12deploy: type: baidu_url_submitter # 为deploy新增一个type 自动推送： 若主题已经集成了自动推送的JS代码，直接在主题配置文件中设置百度推送属性即可。 12# 例如next主题：直接将baidu_push置true即可baidu_push: true 如果主题没有集成自动推送的JS代码，插入主题中layout下的head文件中。 12# 主题不同，可能路径不同，但大都类似于以下路径blog\themes\你的主题\layout\_partial\head.ejs emmmmmm…..推送之后，大概一个礼拜左右 (百度贼慢) ，你就可以在百度搜索到你的博客了。]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo | （二）Next主题个性化设置]]></title>
    <url>%2Fhexo-next-settings.html</url>
    <content type="text"><![CDATA[NexT is a high quality elegant Hexo theme. It is crafted from scratch, with love. Live Preview Muse scheme: LEAFERx | XiaMo | OAwan Mist scheme: Jeff | uchuhimo | xirong Pisces scheme: Vi | Acris | Rainy Gemini scheme: Ivan.Nginx | Raincal | Dandy Installation1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 区分配置文件： 配置文件 路径 站点配置文件 D:/blog/_config.yml 主题配置文件 D:/blog/themes/next/_config.yml 设置RSS1.安装RSS插件 1$ npm install hexo-generator-feed --save 2.编辑站点配置文件，添加以下内容： 12345678#RSS订阅plugin: - hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 0 3.编辑主题配置文件，将rss字段置空。 主题风格12345#Scheme 主题风格scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 四个主题风格，自行选择，消去注释即生效。 设置菜单123456789menu: home: / || home # 主页 tags: /tags/ || tags # 标签 categories: /categories/ || th # 分类 archives: /archives/ || archive # 归档 about: /about/ || user # 关于我# schedule: /schedule/ || calendar # 安排# sitemap: /sitemap.xml || sitemap # 站点地图# commonweal: /404/ || heartbeat # 404公益 添加[标签]、[分类]、[关于]页面只有文章（post）支持[标签]和[分类]。 1.添加[tags]、[categoies]、[about]页面： 123$ hexo new page "tags"$ hexo new page "categories"$ hexo new page "about" 2.在source文件夹中找到新建页面：①编辑tags.md：添加layout:&quot;tags&quot;②编辑categories.md：添加layout:&quot;categories&quot;③编辑about.md，自行发挥。 3.匹配站点配置文件： 123456# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categories 4.匹配主题配置文件中menu： 123456menu: home: / tags: /tags categories: /categories archives: /archives about: /about 5.Front-matter中的[tags]写法： 1234tags:- tag_1- tag_2# 标签之间相互独立 6.Front-matter中的[categories]写法： 12345categories: - 运动- [运动, 球类运动]- [运动, 球类运动, 网球]# 类别存在层级关系 添加自定义页面1.添加自定义页面： 1$ hexo new page "customPage" 2.匹配主题配置文件中的menu： 1234567menu: home: / tags: /tags categories: /categories archives: /archives about: /about customPage: /customPage # 键值对匹配 3.在source中找到customPage.md文件，根据需求自行编辑。 ##添加更新时间 编辑主题配置文件： 123456789post_meta: item_text: true created_at: true # 创建时间 updated_at: true # 更新时间 # Only show 'updated' if different from 'created'. updated_diff: false # 只使用更新时间 # If true, post's time format will be hexo config's date_format + ' ' + time_format. date_time_merge: false categories: true 阅读全文在文章合适的位置添加&lt;!-- more --&gt;，Hexo推荐使用。 设置favicon图标1.将favicon.png放到themes\next\image文件夹下 2.主题配置文件更改图片路径： 12345favicon: small: /images/favicon-16x16.png # 小图标：16x16 medium: /images/favicon-32x32.png # 大图标：32x32 apple_touch_icon: /images/favicon.png # apple图标大图 safari_pinned_tab: /images/logo.svg 设置头像1.将头像图片avatar.png放到themes\next\image文件夹下 2.主题配置文件更改图片路径： 1avatar: /images/avatar.png # avater图片路径 社交账号编辑主题配置文件，自行添加： 1234social: GitHub: https://github.com/yourname || github-icon E-Mail: mailto:youremail || envelope-icon Weibo： https://weibo.com/yourname 友情链接编辑主题配置文件，自行添加： 1234567links_icon: linklinks_title: Links#links_layout: block #块状布局，选一个注一个links_layout: inline #行内布局，选一个注一个links: Github: https://www.github.com 知乎: https://www.zhihu.com 打赏编辑主题配置文件： 12345# Rewardreward_comment: 求打赏文本wechatpay: /images/wechatpay.png # 微信收款二维码 图片路径alipay: /images/alipay.png # 支付宝收款二维码 图片路径#bitcoin: /images/bitcoin.png # 比特币 文章版权信息编辑主题配置文件，启用copyright服务： 12post_copyright: enable: true 访客&amp;访问量NexT主题中已经集成了不蒜子统计，直接编辑主题配置文件： 12345678busuanzi_count: enable: true # 开启busuanzi数据统计 total_visitors: true # 访客 total_visitors_icon: user total_views: true # 访问量 total_views_icon: eye post_views: true # 文章阅读次数 post_views_icon: eye 百度统计1.登录百度统计，添加域名。若更换域名，需重新绑定。 2.复制 hm.js? 后面那串统计脚本 id： 3.编辑主题配置文件，添加脚本id： 12# Baidu Analytics IDbaidu_analytics: 脚本id 文章字数统计1.安装字数统计插件： 1$ npm install hexo-symbols-count-time --save 2.编辑主题配置文件： 123456symbols_count_time: separated_meta: true item_text_post: true # 文章字数 item_text_total: true # 本站所有文章字数 awl: 5 wpm: 200 评论来必力1.登陆 来必力 获取你的 LiveRe UID。 2.编辑主题配置文件，添加LiveRe UID： 1livere_uid: #你的LiveRe UID 3.记住将可评论文档的顶部属性中comments: true 分享jiathis分享编辑主题配置文件，添加jiathis_uid： 12jiathis: uid: 2160658 百度分享编辑主题配置文件，设置baidushare： 12baidushare: type: button # type: button | slide 搜索服务Local Search1.安装local search插件： 1$ npm install hexo-generator-searchdb --save 2.编辑站点配置文件，新增以下内容： 12345search: path: search.xml field: post format: html limit: 10000 3.编辑主题配置文件，启用local search功能： 12local_search: enable: true 修改文章底部标签[#]1.打开编辑themes\next\layout\_macro\post.swig 2.Ctrl+F找到rel=&quot;tag&quot;&gt;# 3.将#替换为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 文章底部添加”本文结束”打开编辑themes\next\layout\_macro\post.swig，在文章结束的地方添加如下代码： 12345&#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt; ---------Thanks for your attention--------- &lt;/div&gt;&#123;% endif %&#125; 添加访客&amp;访问量描述打开编辑themes\next\layout\_third-party\analytics\busuanzi-counter.swig： 添加Host-by描述最近，银牌会员的Coding Pages在访问时会加载广告，需要在网站首页任意位置放置「Hosted by Coding Pages」，通过审核将取消广告。 打开编辑themes/next/layout/_partials/footer.swig，在文件末尾添加如下代码，将「Hosted by Coding Pages」置于页面底部。 123456&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125; &lt;div class="copyright"&gt; Hosted by &lt;a href="https://pages.coding.me"&gt;Coding Pages&lt;/a&gt; &amp;&amp;nbsp;&lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125; DaoVoice实现在线联系1.首先在DaoVoice注册一个账号，注册完成后在[应用设置]-[安装到网站]中找到app_id。 2.打开编辑themes/next/layout/_partials/head/head.swig，添加如下代码： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 3.编辑主题配置文件，添加如下代码： 123# DaoVoicedaovoice: truedaovoice_app_id: yourapp_id 4.设置DaoVoice页面样式 5.在[应用设置]-[添加微信]中绑定微信，关注小程序，即可实时收发消息。 修改Pisces主题宽度打开编辑themes\next\source\css\_schemes\Pisces\_layout.styl，在底部添加如下代码： 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 参考资料：next主题|使用文档]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo | （一）使用Hexo+Pages搭建个人博客]]></title>
    <url>%2Fhexo-blog-build.html</url>
    <content type="text"><![CDATA[本篇主要介绍使用Hexo+Pages搭建个人博客的流程。使用 Hexo 博客框架搭建，解析markdown文章，生成静态页面，将页面托管到 github / coding 服务器上。github / coding 都有pages 服务，提供免费的静态网页托管和演示服务。 搭建步骤： 安装git，nodejs 安装hexo 本地搭建站点（线下访问） 部署到github/coding（线上访问） 站点配置 1. 安装hexo1.安装Git 。安装完毕后，在任意文件夹下鼠标右击即可打开 Git Bash，输入命令，进行Git操作。 1$ git version # 查看Git版本，验证是否安装成功 2.安装Node.js。Hexo是基于nodejs的博客框架，而且nodejs还集成了npm包管理工具。 1$ node -v # 查看nodejs版本，验证是否安装成功 3.安装hexo： 123$ npm install hexo --save # 安装hexo$ npm install hexo-cli -g # 安装hexo命令行模式$ hexo -v # 查看hexo版本，验证是否安装成功 2. hexo建站1.新建一个blog文件夹，打开blog文件夹，Git Bash。 2.hexo初始化：hexo init 3.安装依赖包：npm install 4.初始化完成，在blog下就会生成以下文件目录： 123456789.├── node_modules # 依赖模块├── scaffolds # 文章模板├── source # 用户源文件：页面，文章markdown文件| └── _posts # 创建的文章└── themes # 主题├── .gitignore # git忽略文件信息├── _config.yml # 站点配置文件├── package.json # 已安装插件映射表，下次只需npm install即直接安装表插件 5.hexo本地生成静态页面 12345$ hexo clean # 清理本地静态文件；$ hexo generate # 生成静态页面，即public文件夹；$ hexo server # 启用hexo本地服务器；# 注：Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。# hexo-server安装命令：npm install hexo-server --save 这时，打开浏览器在地址栏输入http://localhost:4000即可本地访问静态博客页面。 3. 配置github/coding pagesgithub和coding可以双线配置，也可以选择其中一个配置。推荐双线配置，coding用于国内访问速度较快，github用于境外访问。 1.登录github，New repository：yourname.github.io。其中yourname是你的github用户名，github强制后缀为github.io才能启用github pages服务。 2.登录coding，新建仓库：yourname.coding.me，打开静态pages服务。其中yourname是你的coding用户名，coding不强制后缀为coding.me。&nbsp;其中yourname是你的coding用户名，coding不强制后缀为coding.me。 3.Git Bash配置git用户信息： 12$ git config --global user.name "YourName"$ git config --global user.email "YourEmail" 4.配置网络传输协议 在管理Git项目时，一般使用ssh或https作为安全传输协议，任选其一即可。 (1) SSH协议 ①SSH秘钥： 123$ ssh-keygen -t rsa -C "youremail@example.com" # 生成rsa秘钥$ cd ~/.ssh # 进入虚拟目录ssh文件中$ cat id_rsa.pub # 显示id_rsa.pub文件内容 ②复制秘钥至github/coding-&gt;用户setting-&gt;SSH keys，New SSH Key； ③验证是否添加成功 12$ ssh -T git@github.com # 验证github是否添加成功$ ssh -T git@coding.net # 验证coding是否添加成功 ④编辑站点配置文件_config.yml： 123456deploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git coding: git@git.coding.net:yourname/yourname.coding.me.git branch: master (2) HTTPS协议 ①直接编辑站点配置文件_config.yml： 123456deploy: type: git repo: github: https://github.com/liziczh/liziczh.github.io.git coding: https://git.coding.net/liziczh/liziczh.coding.me.git branch: master ②验证github/coding用户名和密码。 4. 部署到github/coding1.安装Git部署插件： 1$ npm install hexo-deployer-git --save 2.部署： 123$ hexo clean # 清理本地静态文件；$ hexo generate # 生成静态页面，即public文件夹；$ hexo deploy # 部署到github/coding； 3.部署完毕，站点文件目录如下： 123456789101112.├── .deploy_git # （新增）hexo deploy 生成的git部署文件├── public # （新增）hexo generate 生成的静态文件├── db.json # （新增）hexo generate 生成的数据├── node_modules # 依赖模块├── scaffolds # 文章模板├── source # 用户源文件：页面&amp;文章的markdown文件| └── _posts # 文章└── themes # 主题├── .gitignore # git时需忽略文件├── _config.yml # 站点配置文件├── package.json # 已安装插件映射表，下次只需npm install即直接安装表插件 站点搭建完毕，打开浏览器在地址栏输入以下链接可随时访问自己的博客了。 github pages：http://yourname.github.io coding pages：http://yourname.coding.me 5. 站点配置区分配置文件： 配置文件 路径 站点配置文件 D:/blog/_config.yml 主题配置文件 D:/blog/themes/你的主题/_config.yml 打开站点配置文件blog/_config.yml，自行发挥，配置完毕，重新部署 hexo g -d； 12345678910111213141516171819202122232425# 注意：yaml语言使用缩进表示层级关系。# 注意：键值对中的冒号（:）后面有一个半角空格。# 网站title: #网站标题subtitle: #网站副标题description: #网站描述keywords: #关键字author: #你的名字,文档作者language: #网站的语言timezone: #时区，中国：Asia/Shanghai# 网址url: https://yoursite.com #你的网址urlroot: /permalink: :year/:month/:day/:title.html #文章永久链接permalink_defaults:# 主题theme: landscape # 主题文件的名称# 部署deploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git coding: git@git.coding.net:yourname/yourname.coding.me.git branch: master 详细配置请参考hexo配置，此处不再赘述。 6. 主题变更1.hexo默认主题为landscape，可以到Themes|Hexo选择自己喜欢的主题，复制主题在github仓库的url。 2.在themes文件夹下，打开GitBash，克隆主题至themes文件夹中。 1$ git clone https://github.com/theme-next/hexo-theme-next.git 克隆之后，记住删除themes\你的主题名中的.git，.github，.gitignore等Git仓库文件。 3.更改站点配置文件_config.yml： 1theme: 主题文件名 4.编辑结束，重新部署： 12$ hexo clean # 清理缓存文件；（不清理也可以部署，推荐先清理）$ hexo g -d # 生成静态页面后直接部署； 部署完毕之后，进入以下链接刷新就可以看到你的新主题了。 github pages：http://yourname.github.io coding pages：http://yourname.coding.me 7. 写作1.新建：在blog文件夹下，打开Git Bash，新建文章： 1$ hexo new post "title" 2.编辑：在source/_post下可以编辑你新建的文章。 3.编辑完毕，重新部署： 12$ hexo clean # 清理缓存文件；（不清理也可以部署，推荐先清理）$ hexo g -d # 生成静态页面后直接部署； 8. 文档的Front-matterFront-matter 是文档最上方以 --- 分隔的区域，用于指定文档一些的参数。 12345678---title: 文章标题date: yyyy-MM-dd hh:mm:sstags: categories: comments: true---# 注意：键值对中的冒号（:）后面有一个半角空格。 参数 值 描述 layout postpagedraftfalse 文章【默认值】页面草稿不处理 title 文本 标题 date yyyy-MM-dd hh:mm:ss 文件建立日期 update yyyy-MM-dd hh:mm:ss 文件更新日期 comments truefalse 开启文章评论功能，默认true tags 标签（只适用于post） categories 分类（只适用于post） permalink url 永久链接 不要处理我的文章：将文章Front-Matter中的layout: false； 9. 文章的[标签]与[分类]只有文章（post）支持[标签]和[分类]。 1.添加[tags]、[categoies]、[about]页面： 123$ hexo new page "tags"$ hexo new page "categories"$ hexo new page "about" 2.在source文件夹中找到新建页面：①编辑tags.md：添加layout:&quot;tags&quot;；②编辑categories.md：添加layout:&quot;categories&quot;；③编辑about.md，自行发挥。 3.匹配站点配置文件： 123456# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categories 4.匹配主题配置文件中menu： 123456menu: home: / tags: /tags categories: /categories archives: /archives about: /about 5.Front-matter中的[tags]写法： 1234tags:- tag_1- tag_2# 标签之间相互独立 6.Front-matter中的[categories]写法： 12345categories: - 运动- [运动, 球类运动]- [运动, 球类运动, 网球]# 类别存在层级关系 重新部署之后，个人博客的基本功能，写作，标签，分类，归档就全部实现了。 10. 绑定自己的域名若不喜欢域名后缀为github.io或coding.me，可以自己注册一个域名进行绑定。 1.域名注册：在阿里云/腾讯云等注册一个域名。 2.添加CNAME文件：在blog\source下，添加一个CNAME文件 (无文件后缀)，内容为你的域名example.com。 3.Github Pages域名解析：①添加四个A记录：主机记录为@，记录值为185.199.108.153、185.199.109.153、185.199.110.153、185.199.111.153。②添加一个CNAME记录：主机记录为www，记录值为yourname.github.io。 4.Coding Pages域名解析：①打开控制台ping pages.coding.me，获取IP。②添加一个A记录：主机记录为@，记录值为ping得的IP。③添加一个CNAME记录：主机记录为www，记录值为pages.coding.me。 由于国内访问Github Pages速度较慢，所以我将Coding Pages解析线路设为默认，供国内访问；将Github Pages解析线路设为境外，供国外访问。 Chrome无法访问链接问题问题描述：部署页面之后，Chrome无法访问链接，提示你的连接不是私密连接……解决方案：前往chrome://net-internals/#hsts，在Delete domain中输入无法访问的网页地址。 附：hexo常用命令 命令 描述 hexo version 显示 Hexo 版本 hexo init [folder] 新建一个网站若未设置folder，默认为当前文件夹； hexo new [layout] &quot;title&quot; 新建一篇文档，文档布局由layout决定 hexo clean 清理缓存文件 hexo generatehexo g 生成静态页面 hexo serverhexo s 启用服务器，http://localhost:4000 hexo deployhexo d 部署文件 hexo g -dhexo d -g 生成静态文件后直接部署部署之前先生成静态文件 若想了解更多关于hexo命令的介绍，请参考指令 | hexo]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows | 系统重装&系统启动模式]]></title>
    <url>%2Fwindows-reos.html</url>
    <content type="text"><![CDATA[使用微软官方工具制作系统启动U盘，安装微软原版 Windows 系统，了解Windows系统的启动模式。 Windows 系统重装一、准备工作Win7 下载1.下载系统镜像：搜索mdsn，我告诉你，复制系统的【ed2k链接】，粘贴至迅雷下载系统ISO文件。 2.制作启动U盘：下载微软官方工具 Windows USB/DVD Download Tool，格式化U盘，制作启动盘。 3.下载网卡驱动：登录【本机机型官网】，寻求【服务支持】，下载【网卡驱动程序】。 Win10 下载1.下载微软官方工具 MediaCreationTool.exe ，选择【为另一台电脑创建安装介质】，制作启动U盘。 二、重装系统1.BIOS设置：开机进入【BIOS设置程序】，设置【USB】为【第一启动项】，保存退出。 ？：机型不同，进入BIOS方式不同，BIOS设置也不同，根据机型自行百度； 2.磁盘分区：进入系统安装界面，安装方式选择【自定义安装】，根据需求自行分区。 ？：如果是win10/8换win7，需要将GPT分区转换为MBR分区；？：如果是win7升win10/8，需要将MBR分区转换为GPT分区； 12345678&gt; # 在windows系统安装界面 Shift+F10 调出控制台。&gt; diskpart # 进入DiskPart工具&gt; list disk # 列出磁盘信息&gt; select disk n # 选择需要操作的磁盘，n为磁盘编号。&gt; clean # 清理磁盘所有数据&gt; convert mbr # 转换为MBR分区形式&gt; convert gpt # 转换为GPT分区形式&gt; 3.根据需求设置系统时间日期地区等等信息，等待系统安装…… 4.安装驱动：安装网卡驱动，连接网络，安装其他驱动。 Win7系统：安装已下载的网卡驱动。连接网络，可以前往【本机机型官网】下载驱动选择，也可以下载驱动软件【驱动大师】【驱动精灵】等一键安装。 Win10系统：自动安装驱动。 5.BIOS设置：开机进入【BIOS设置程序】，设置【HardDisk】为【第一启动项】，保存退出。 6.系统激活：在淘宝10块钱买个激活码，激活系统。 了解Windows系统启动模式一、Windows 系统启动方式 Legacy BIOS 启动：在开机时需进行自检，启动过程较复杂。并且BIOS无法识别GPT分区，所以在Legacy BIOS模式下，采用GPT方式分区的磁盘无法安装操作系统，只能用于数据存储。 UEFI 启动：直接从预启动的操作环境加载操作系统，简化开机过程有效提高启动速度。并且可以同时识别MBR和GPT，在UEFI模式中MBR和GPT都支持安装操作系统，但微软规定，在UEFI模式只能使用GPT硬盘安装Windows系统。 二、磁盘分区方式 MBR分区：主引导记录磁盘分区格式。采用MBR分区，主分区数目不能超过4个，而且由于MBR分区方式用4个字节存储分区的总扇区数，按每扇区512字节计算，无法支持超过2TB容量的磁盘。 GPT分区：GUID全局唯一标识磁盘分区表。GPT的先进之处在于GPT分区表头可自定义分区数量的最大值，即GPT分区表的大小不是固定的。GPT采用64位二进制数表示逻辑块地址，所以分区个数和分区大小几乎没有限制，但Windows系统最多只允许划分128个分区。 Legacy BIOS+MBR支持安装所有的Windows系统。UEFI+GPT支持Win7-64位及Win7之后的操作系统。]]></content>
      <categories>
        <category>电脑维修</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web | jQuery]]></title>
    <url>%2Fweb-jquery.html</url>
    <content type="text"><![CDATA[jQuery 是一个 JavaScript 函数库，将 JS 的一些功能实现封装成了函数，极大地简化了 JavaScript 编程。jQuery是 John Resig 于2006年创建的一个开源项目，jQuery集成了 JavaScript、CSS、 DOM 和 Ajax 于一体的强大功能。它可以用最少的代码， 完成更多复杂而困难的功能。 1. 引入jQuery1.1 jQuery版本jQuery版本： jQuery-1.x.x：兼容IE6/7/8低级浏览器。 jQuery-2.x.x：不兼容IE6/7/8。 jQuery-3.x.x：全面支持HTML5和CSS3。 jQuery版本分类： Development version：[jquery.js] 开发版，未压缩，用于测试和开发。 Production version：[jquery.min.js] 精简版，已被压缩。 1.2 引入jQuery123&lt;head&gt; &lt;script type="text/javascript" src="js//jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;/head&gt; 2. jQuery入门2.1 jQuery对象与DOM对象jQuery简化了JS编程，多数JS功能实现都被封装成了函数，而调用这些jQuery函数必须使用jQuery对象。 jQuery对象本质是一个DOM对象数组。 12345// DOM对象转jQuery对象var $jQueryObj = $(DOMObj);// jQuery对象转DOM对象var DOMObj = $jQueryObj[0];var DOMObj = $jQueryObj.get(0); jQuery对象命名一般以$为前缀 2.2 jQuery入口函数第一种写法： 123$(document).ready(function()&#123; jQuery代码&#125;); 第二种写法： 123$(function()&#123; jQuery代码&#125;); jQuery入口函数与JS入口函数的区别：①jQuery的入口函数只等待DOM树加载完即执行；②JS入口函数需要等待所有资源加载完成再执行； 2.3 jQuery基础语法1$("选择器").操作函数() $()：即jQuery()，本质是一个函数。 3. jQuery选择器jQuery选择器：获取元素 3.1 元素选择器 元素选择器 描述 * 通配符选择器 #id id选择器 .class 类选择器 element 元素选择器 s1s2 交集选择器 s1,s2 并集选择器 s1 s2 后代选择器 s1 &gt; s2 子元素选择器 3.2 属性选择器 属性选择器 描述 [attr] 属性选择器 [attr=value] 属性=值的元素 [attr!=value] 属性!=值的元素 [attr$=value] 属性值以value结尾的元素 3.3 过滤选择器 位置 描述 :first 第一个元素 :last 第二个元素 :odd 所有奇数元素 :even 所有偶数元素 索引位置 描述 :eq(index) 指定索引的元素（index从0开始） :gt(num) 所有索引&gt;num的元素 :lt(num) 所有索引&lt;num的元素 标签类型 描述 :header 所有标题元素 :animated 所有动画元素 元素状态 描述 :contains(text) 包含指定文本的元素 :empty 无子节点的元素 :hidden 所有隐藏的元素 :visible 所有可见的元素 3.4 表单选择器 表单元素 描述 :input 所有&lt;input&gt;元素 :text 所有type=&quot;text&quot;的 &lt;input&gt; 元素 :password 所有type=&quot;password&quot;的&lt;input&gt;元素 :radio 所有type=&quot;radio&quot;的&lt;input&gt;元素 :checkbox 所有type=&quot;checkbox&quot;的&lt;input&gt;元素 :submit 所有type=&quot;submit&quot;的&lt;input&gt;元素 :reset 所有type=&quot;reset&quot;的&lt;input&gt;元素 :button 所有type=&quot;button&quot;的&lt;input&gt;元素 :image 所有type=&quot;image&quot;的&lt;input&gt;元素 :file 所有type=&quot;file&quot;的&lt;input&gt;元素 :enable 所有激活的&lt;input&gt;元素 :disabled 所有禁用的&lt;input&gt;元素 :selected 所有被选取的&lt;input&gt;元素 :checked 所有被选中的&lt;input&gt;元素 4. jQueryDOM★4.1 DOM 操作★4.1.1 DOM HTML内容1.text()：设置/获取所选元素的文本内容 12$("selector").text(); // 获取文本内容$("selector").text("文本内容"); // 设置文本内容 2.html()：设置/获取所选元素的内容 12$("selector").html(); // 获取HTML内容$("selector").html("HTML代码"); //设置 HTML内容 3.val()：设置/获取表单字段的值 12$("selector").val(); // 获取表单字段的值$("selector").val("表单字段值"); // 设置表单字段的值 4.1.2 DOM HTML属性1.attr()：HTML属性，只能返回string的结果 123$("selector").attr("属性名"); // 获取HTML属性$("selector").attr("属性名", "值"); // 设置HTML属性$("selector").attr(&#123;"属性名":"值", "属性名":"值"&#125;); // 设置多个HTML属性 2.prop()：DOM属性，如selected，disabled，checked等属性。 123$("selector").prop("属性名"); // 获取属性$("selector").prop("属性名", "值"); // 设置属性$("selector").prop(&#123;"属性名":"值", "属性名":"值"&#125;); // 设置多个属性 4.1.3 DOM 插入元素1.append()：在被选元素的结尾追加内容 1$("selector").append("插入内容"); 2.prepend()：在被选元素的开头插入内容 1$("selector").prepend("插入内容"); 3.before()：在被选元素之前插入内容 1$("selector").before("插入内容"); 4.after()：在被选元素之后插入内容 1$("selector").after("插入内容"); 4.1.4 DOM 删除元素1.remove()：删除被选元素及其子元素 1$("selector").remove(); 2.empty()：删除被选元素的所有子元素 1$("selector").empty(); 4.1.5 DOM CSS类1.addClass()：向被选元素添加一个或多个样式类 1$("selector").addClass("类名"); 2.removeClass()：从被选元素移除一个或多个类 1$("selector").removeClass("类名"); 3.toggleClass()：对被选元素进行类切换（本质是类的添加/删除） 1$("selector").toggleClass("类名"); 4.hasClass()：判断被选元素是否存在类 1$("selector").hasClass("类名"); 4.1.6 DOM CSS属性1.css()：设置或返回样式属性 123$("selector").css("样式属性"); // 获取样式属性值$("selector").css("样式属性","值"); // 设置样式属性$("selector").css(&#123;"样式属性":"值","样式属性":"值",...&#125;); // 设置多个样式属性 4.1.7 DOM 元素尺寸1.width()：设置或返回元素的宽度（不包括内边距、边框、外边距） 1$("selector").width(); 2.height()：设置或返回元素的高度（不包括内边距、边框、外边距） 1$("selector").height(); 3.innerWidth()：返回元素的宽度（包括内边距） 1$("selector").innerWidth(); 4.innerHeight()：返回元素的高度（包括内边距） 1$("selector").innerHeight(); 5.outerWidth()：返回元素的宽度（包括内边距、边框） 1$("selector").outerWidth(); 6.outerHeight()：返回元素的高度（包括内边距、边框） 1$("selector").outerHeight(); 7.outerWidth(true)：返回元素的宽度（包括内边距、边框和外边距） 1$("selector").outerWidth(true); 8.outerHeight(true)：返回元素的高度（包括内边距、边框和外边距） 1$("selector").outerHeight(true); 4.1.8 DOM 位置1.scrollTop()：滚动条顶部偏移量 1$("selector").scrollTop(); 2.scrollLeft()：滚动条左边偏移量 1$("selector").scrollLeft(); 4.2 DOM 遍历★4.2.1 向上遍历-祖先1.parent()：返回被选元素的直接父元素 1$("selector").parent("筛选选择器"); // 直接父元素，可筛选 2.parents()：返回被选元素的所有祖先元素，向上遍历直到根&lt;html&gt; 1$("selector").parents("筛选选择器"); // 所有祖先元素，可筛选 3.parentsUntil()：返回介于两个给定元素之间的所有祖先元素 1$("selector1").parentsUntil("selector2"); 4.2.2 向下遍历-后代1.children()：返回被选元素的所有直接子元素 1$("selector").children("筛选选择器"); // 返回直接子元素，可筛选 2.find()：返回被选元素的所有后代元素 1$("selector").find("筛选选择器"); // 返回后代元素，可筛选 4.2.3 水平遍历-兄弟1.siblings()：返回被选元素的所有兄弟元素 1$("selector").siblings("筛选选择器"); // 返回所有兄弟元素，可筛选 2.next()：返回被选元素的下一个兄弟元素 1$("selector").next("筛选选择器"); // 返回下一个兄弟元素，可筛选 3.nextAll()：返回被选元素之后的兄弟元素 1$("selector").nextAll("筛选选择器"); // 返回元素之后的兄弟元素，可筛选 4.nextUntil()：返回介于两个给定元素之间的所有兄弟元素 1$("selector1").nextUntil("selector2"); // 从selector1水平向后遍历直到selector2 5.prev()：返回被选元素的上一个兄弟元素 1$("selector").prev("筛选选择器"); // 返回上一个兄弟元素，可筛选 6.prevAll()：返回被选元素之前的同胞元素 1$("selector").prevAll("筛选选择器"); // 返回元素之前的兄弟元素，可筛选 7.prevUntil()：返回介于两个给定元素之间的所有同胞元素 1$("selector1").prevUntil("selector2"); // 从selector1水平向前遍历直到selector2 4.2.3 元素筛选1.eq()：返回被选元素中带有指定索引的元素 1$("selector").eq(index); // 返回指定索引的元素 2.filter()：返回匹配筛选标准的元素 1$("selector").filter("筛选选择器"); // 返回匹配筛选选择器的元素 3.not()：返回不匹配筛选标准的元素 1$("selector").not("筛选选择器"); // 返回不匹配筛选选择器的元素 4.first()：获取第一个元素 1$("selector").first(); 5.last()：获取最后一个元素 1$("selector").last(); 5. jQuery效果5.1 隐藏/显示1.show()：显示 1$("selector").show(speed,callback); 2.hide()：隐藏 1$("selector").hide(speed,callback); 3.toggle()：切换hide()/show() 1$("selector").toggle(speed,callback) speed：速度(ms)，[可选参数]callback：当前动画 100% 完成之后执行的函数，[可选参数] 5.2 淡入/淡出-fade1.fadeIn()：淡入已隐藏的元素 1$("selector").fadeIn(speed,callback); 2.fadeOut()：淡出已显示的元素 1$("selector").fadeIn(speed,callback); 3.fadeToggle()：切换fadeIn()和fadeOut() 1$("selector").fadeToggle(speed,callback); 4.fadeTo()：允许渐变为给定的不透明度 1$("selector").fadeTo(speed,opacity,callback); speed：速度(ms)，[可选参数]opacity：不透明度(0~1)，[可选参数]callback：当前动画 100% 完成之后执行的函数，[可选参数] 5.3 滑动-slide1.slideDown()：向下滑动元素 1$("selector").slideDown(speed,callback); 2.slideUp()：向上滑动元素 1$("selector").slideUp(speed,callback); 3.slideToggle()：切换slideDown()和slideUp() 1$("selector").slideToggle(speed,callback); 5.4 自定义动画-animateanimate()：自定义动画 1$("selector").animate(&#123;params&#125;,speed,callback); params：定义形成动画的CSS属性，[必要参数]speed：速度(ms)，[可选参数]callback：当前动画 100% 完成之后执行的函数，[可选参数] 5.5 停止效果-stopstop()：在动画或效果完成前对它们进行停止 1$("selector").stop(stopAll,goToEnd); stopAll：是否清除动画队列；默认false-仅停止活动的动画，允许队列中后面的动画执行。goToEnd：是否立即完成当前动画 ；默认false。 6. jQuery事件机制6.1 事件类型 事件句柄 描述 ready DOM载入 click 鼠标单击 focus 元素获得焦点 blur 元素失去焦点 mouseover 鼠标覆盖 mouseout 鼠标移开 mouseup 鼠标点击 mousedown 鼠标松开 scroll 窗口滚动 change 发生改变 unload 退出页面 submit 点击提交 keydown 某个键盘的键被按下 keypress 某个键盘的键被按下或按住 keyup 某个键盘的键被松开 6.2 事件绑定方式1.简单事件绑定： 1$("selector").事件(handler); 一次只能绑定一个事件 2.bind()：事件绑定 1$("selector").bind("events"[,data],handler); bind()不支持动态绑定。 3.delegate()：事件委托 1$("selector").delegate("childSelector","events"[,data],handler); 通过委托父元素可以动态为当前或未来子元素绑定事件； 4.on()：统一事件绑定方式，推荐使用 1$("selector").on("events"[,"childSelector"][,data],handler) events：事件，多个事件以空格分隔childSelector：后代元素，[可选]data：传递给handler的数据，事件触发后通过event.data调用，[可选]handler：事件处理函数 6.3 事件移除方式1.unbind()：移除被选元素的事件 1$("selector").unbind("events",handler); 2.undelegate()：移除由delegate()添加的事件 1$("selector").undelegate("selector","events",handler); events：规定需要删除处理函数的一个或多个事件类型 ，[可选]selector：规定需要删除事件的选择器 ，[可选]handler：规定要删除的具体事件处理函数 ，[可选] 3.off()：解除事件绑定，推荐使用 1$("selector").off("events"[,"selector"][,handler],map); events：规定需要删除处理函数的一个或多个事件类型 ，[可选]selector：规定需要删除事件的选择器 ，[可选]handler：规定要删除的具体事件处理函数 ，[可选]map：规定事件映射 ({event:function, event:function, …}) ，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。 7. jQuery杂项（难点）7.1 链式编程链式编程：使用一个jQuery对象不断地调用(点调用)函数。栗子如下： 1$("div").addClass("highlight").children("a").show().end().siblings().removeClass("highlight").children("a").hide(); 非筛选函数：函数返回当前jQuery对象，jQuery对象不发生改变，如addClass()，hide()…筛选函数：函数返回新的jQuery对象，如find()，parent()… 链式编程原理：jQuery的非筛选函数都返回其本身 1return this end()：结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态 1jQueryObj.end() 链式编程本质★：jQuery对象(即包装后的DOM对象)①调用筛选/遍历函数后返回新的jQuery对象，将新的jQuery对象压入栈内；②调用非筛选/遍历函数后返回本身(return this)。③调用end()将栈顶元素 (当前jQuery对象) 弹出栈，指向新的栈顶元素 (最近上一次的jQuery对象)。 7.2 隐式迭代隐式迭代：jQuery对象本质是DOM对象数组，即$(&quot;selector&quot;)返回一个对象数组。jQuery会自动对匹配到的DOM数组进行循环遍历，执行所调用的函数。 设置操作：隐式迭代，循环遍历DOM对象数组执行设置函数。 获取操作：大部分情况下返回第一个元素的值。 7.3 each方法each()：为每个匹配元素规定运行的函数 1$("selector").each(function(index,element)); function()：为每个匹配元素规定运行的函数，[必要参数]index：选择器的index位置element：当前的元素 7.4 多库共存jQuery使用$标识符作为jQuery的简写符号 ，如果页面上同时存在其他JS库正在使用相同的简写符号$怎么办呢？ noConflict()：释放$标识符的控制 1var a = $.noConflict(); // 释放$的控制权，将$的能力赋予a。 8. jQuery应用Ajax未完待续…]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web | JavaScript]]></title>
    <url>%2Fweb-javascript.html</url>
    <content type="text"><![CDATA[JavaScript 是一种通用的网络脚本语言，常用来为网页改进设计、验证表单、添加动态功能等，实现用户交互。JavaScript 是一门轻量级，解释型，基于原型，面向对象，弱类型的网络脚本语言。 解释型：无需编译，在程序运行中逐行进行解释执行。 弱类型：对使用的数据类型不严格要求。 面向对象：JS 基本对象，DOM 对象，BOM 对象。 跨平台：不依赖于操作系统，仅需要浏览器的支持。 1. JS基础1.1 JS使用方式1.行内js： 1&lt;input type="button" value="js" onclick="javascript:alert('hello')" /&gt; 2.内部js： 123&lt;script&gt; js代码&lt;/script&gt; 3.外部js：外部js文件 4.引入外部js文件： 12&lt;!--引入外部js--&gt;&lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt; 1.2 JS注释1.单行注释： 1// 单行注释 2.多行注释： 123/* 多行注释 */ 1.3 JS输出语句123alert(); //弹出框输出console.log(); //在console显示document.write(); //写入HTML文件中 1.4 JS标识符JS标识符命名规则：①见名知意②驼峰命名法：首个单词全小写，之后的单词首字母大写。③abc123_$④不能以数字开头⑤不能使用关键字⑥严格区分大小写 1.5 JS变量1.5.1 变量声明JS是弱类型的，无需明确的变量声明，同一个变量可以存放不同类型的值。 1.JS使用var声明变量： 1var a = 3; //JS使用var声明变量 2.JS直接使用标识符声明变量： 1x = 4; //JS直接使用标识符声明变量，全局变量； 1.5.2 变量作用域 变量类型 描述 全局变量 定义在函数外的var变量 &amp; 无var变量 局部变量 定义在函数内的var变量 1.5.3 变量提升★变量提升（Hoisting）：JS函数及变量的声明都将被提升到函数的最顶部。 1.6 JS数据类型JS是一种弱类型语言（动态类型），同一个变量可存放不同类型的值。 typeof操作符：检测变量数据类型； 123456789typeof 3.14 //number 数字typeof NaN //number 数字typeof '123' //string 字符串typeof true //boolean 布尔值typeof undefined //undefined 未赋值变量typeof null //object 空对象引用typeof &#123;&#125; //object 对象typeof [] //object 数组对象typeof alert() //function 函数 1.6.1 原始类型1.Number | 数字： 123453; // 整数3.4; // 浮点数123e5; // 科学计数法0xFFFF; // 十六进制数NaN; // 非数字，任何涉及NaN的计算，都返回NaN。 2.String | 字符串： 123"abc"; // 双引号字符串'abc'; // 单引号字符串"\r\n"; // 转义字符 转义字符 描述 \n 换行 \r 回车 \t 制表 \b 退格 \&#39; &#39; \&quot; &quot; \\ \ 3.Boolean | 布尔型： 12true; // true值false; // false值 4.Undefined | 未赋值变量： 1undefined; // 意为"缺少值"，未赋值的变量;（用于变量类型） 5.Null | 空指针： 12null; // 空对象指针，（用于对象类型）/* typeof null，类型为Object; */ -区分undefined和null★： 123number(null)==0number(undefined)==NaN;/* 目前null与undefined基本同义 */ 1.6.2 类型转换1.转换成字符串： 1.toString(); // null,undefined没有toString() 2.转换成数字： 12.parseInt("123red",10); // 返回123，逐个字符判断.parseFloat("1.2.3",10); // 返回1.2，逐个字符判断 强制类型转换： 1.Number()： 1234567Number(1.2) // 1.2Number(1.2.3) // NaNNumber(false) // 0Number(true) // 1 Number(undefined) // NaNNumber(null) // 0Number(new object()) // NaN 2.String()： 123String(); // 转换任意数据类型String(null); // "null"String(undefined); // "undefined" 3.Boolean()： 123456/* false：空字符串，0，undefined，null */Boolean(""); //false：空字符串Boolean(0); //false：0Boolean(undefined); //false：undefinedBoolean(null); //false：nullBoolean(new object()); //true - 对象 1.6.3 引用类型引用类型：对象，一组属性和方法的集合。 1.Object | 对象：{} 1234567var obj = &#123; var name = "张三"; var age = 20; var eat = function()&#123; alert(this.name + "正在吃饭~"); &#125;&#125;; 1var obj = new Object(); // Object对象 2.Array | 数组：[] 1var arr = [1,2,3]; // 字面量 1var arr = new Array(1,2,3); //数组对象 3.Function | 函数： 1function f()&#123;&#125; // 一般函数声明 1var f = function()&#123;&#125; // 函数表达式 1var f = new Function(arg1, arg2, ..., argN, function_body) // 函数对象 更多引用类型：String，Boolean，Number，Math，Date，RegExp，Error，EvalError，RangeError，ReferenceError，SyntaxError，TypeError，URIError。 1.7 JS运算符1.算术运算符：+，-，*，/，%，++，--2.关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=3.逻辑运算符：&amp;，|，~，^，!，&amp;&amp;，||4.位运算符：&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，~，&amp;，|，^5.赋值运算符：=，+=，-=，*=，/=，%=6.条件运算符：a?b:c 双等与三等★：==&amp;!=：只比较值，不比较类型。===&amp;!==：既比较值，也比较类型。 1.8 JS语句1.8.1 选择语句if语句： 12345if(条件表达式)&#123; 条件为true执行语句;&#125;else&#123; 条件为false执行语句;&#125; switch语句： 1234567891011switch(n)&#123;case 1: 执行代码块 1 break;case 2: 执行代码块 2 break;default: 与以上case值不同时执行的代码&#125; 1.8.2 循环语句while循环： 12345var i = 0;while(i&lt;10)&#123; 循环体; i++;&#125; do while循环： 123456// 先执行一次后判断var i = 0;do&#123; 循环体; i++;&#125;while(i&lt;10); for循环： 123for(var i = 0;i&lt;10;i++)&#123; 循环体;&#125; for-in循环： 123for(var i in 对象)&#123; 循环体;&#125; 1.8.3 跳转语句 跳转语句 描述 break 跳出当前循环，跳出一层循环； continue 跳出本次循环，进行下次循环； return 结束整个方法； 2. JS高级2.1 JS字符串JS字符串本质是一个不可变的字符数组。 2.1.1 创建字符串1.使用字面量创建字符串： 1var str = "abc"; // 字面量 2.使用String对象创建字符串： 1var str = new String("abc"); // String对象 2.1.2 字符串拼接1var str = "abc"+"def"; // 使用“+”拼接字符串 2.1.3 String对象 string属性&amp;方法 描述 length 返回字符串长度 charAt(number) 返回指定索引位置的字符 charCodeAt() 返回指定索引位置字符的 Unicode 值 concat() 连接字符串 substring() 提取字符串中两个指定的索引号之间的字符 substr() 从起始索引号提取字符串中指定数目的字符 slice() 提取字符串片断，并在新字符串中返回被提取部分 indexOf() 返回字符串中检索指定字符第一次出现的位置如果没有返回-1 lastIndexOf() 返回字符串中检索指定字符最后一次出现的位置如果没有返回-1 trim() 移除字符串首尾空格 toUpperCase()toLowerCase() 大小写转换 localeCompare() 比较两个字符串大小 match() 找到一个或多个正则表达式的匹配 search() 检索与正则表达式相匹配的值，返回位置 replace() 替换与正则表达式匹配的子串 split() 把字符串分割为子字符串数组 2.2 JS数组JS数组是动态数组，无需指定长度。JS又是弱类型的，数组中可以有不同的变量类型。 2.2.1 创建数组1.使用字面量创建： 1var arr=["a","b","c"]; // 字面量 2.使用Array创建： 1var arr=new Array("a","b","c"); // Array对象 2.2.2 遍历数组1.使用普通for循环遍历： 123for(var i = 0 ; i &lt; arr.length ; i++)&#123; console.log(arr[i]);&#125; 2.使用for-each遍历： 123for(var i in arr)&#123; console.log(arr[i]);&#125; 2.2.3 Array对象 Array方法 描述 length 返回数组长度 isArray() 判断是否为数组 valueOf() 返回数组对象的原始值 toString() 将数组以字符串的形式返回 push() 向数组末尾追加元素，返回新的长度 pop() 删除并返回数组的最后一个元素 join() 将数组转换为字符串，默认按逗号隔开 shift() 删除并返回数组的第一个元素 unshift() 向数组的开头追加元素，返回新的长度 reverse() 数组反转 slice() 从某个已有的数组返回选定的元素 splice() 删除元素，并向数组添加新元素 sort() 排序；数字按大小排，字母按字典顺序排，汉字按Unicode排 indexOf() 返回元素索引 lastIndexOf() 返回元素反序索引 2.3 JS函数JS函数是一种数据类型[function]，JS函数也是对象。 2.3.1 函数定义1.使用函数声明定义： 1function 函数名(arg0, arg1, ... argN)&#123;&#125; // 函数声明 2.使用函数表达式定义： 1var 函数名 = function(arg0, arg1, ... argN)&#123;&#125; // 函数表达式 | 匿名函数 3.使用构造函数定义： 1var function_name = new Function(arg1, arg2, ..., argN, function_body) 4.自执行函数：自己调用自己 123(function 函数名([形参])&#123; 函数体;&#125;)([实参]); 2.3.2 函数提升★一等公民：JS函数与JS变量处于同等地位，可作为一个值使用。①可将函数赋值给变量②可将函数赋值给对象的属性③可将函数作为参数出入其他函数④可将函数作为返回结果 函数提升（Hoisting）：JS函数及变量的声明都将被提升到函数的最顶部。 2.3.3 Function对象1.JS函数实际上是功能完整的对象。 function属性&amp;方法 描述 eval(“JS代码”) 执行JS代码 escape() 对字符串进行编码 unescape() 对字符串进行解码 encodeURI() 把字符串编码为 URI decodeURI() 解码某个编码的 URI isNaN() 判断是否是非数字 Number() 把对象转换为数字 String() 把对象转换为字符串 parseInt() 解析一个字符串并返回一个整数 parseFloat() 解析一个字符串并返回一个浮点数 2.JS函数不会重载，只会执行最后一个函数。 123var doAdd = new Function("num", "alert(num + 20)");var doAdd = new Function("num", "alert(num + 10)");doAdd(1); // 返回11 2.3.4 arguments对象JS函数内置对象：arguments对象，表示函数调用的参数数组。 1.检测参数个数： 1arguments.length // 参数数组长度，参数个数 2.模拟函数重载：使用arguments.length判断传递给函数的参数个数，即可模拟重载。 123456789function doAdd() &#123; if(arguments.length == 1) &#123; alert(arguments[0] + 1); &#125; else if(arguments.length == 2) &#123; alert(arguments[0] + arguments[1]); &#125;&#125;doAdd(10); // 返回11doAdd(10,20); // 返回30 2.3.5 JS闭包★闭包（closure）指的是词法表示包括不被计算的变量的函数，即函数可以使用函数之外定义的变量。 123456789// 闭包实例var iBaseNum = 10;function addNum(iNum1, iNum2) &#123; function doAdd() &#123; return iNum1 + iNum2 + iBaseNum; // 内部函数作为闭包，获取外部函数的参数iNum1、iNum2，以及全局变量iBaseNum。 &#125; // doAdd()函数根本不接受参数，它使用的值是从执行环境中获取的。 return doAdd(); &#125; 2.4 JS对象2.4.1 Object对象 Object属性&amp;方法 描述 constructor 指向对象构造器 prototype 指向对象原型 Object.assign({}, obj) 对象复制 Object.assign(obj1, obj2, obj3) 对象合并 Object.create(proto, [prop_Object]) 模拟类（class） Object.is(obj1, obj2) 判断两个值是否严格相同 Object.keys(obj) 返回对象所有属性的数组 Object.delete(obj.prop) 删除对象某个属性 in操作符：判断属性是否属于对象。 1prop in obj // 判断prop是否属于obj 2.4.2 内置对象JS内置对象（本地对象/全局对象）：由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现。 JS内置对象：Object，String，Array，Function，Boolean，Number，Math，Date，RegExp，Error等。 其中Object，String，Array，Function请参考上文。 Number对象： Number属性&amp;方法 描述 NaN 非数字值 MAX_VALUE 最大值 MIN_VALUE 最小值 toFixed(n) 返回指定n位小数的数字的字符串 toExponential() 返回指数为n的科学计数法的数字的字符串 toPrecision() 把数字四舍五入格式化为指定的长度 Math对象：静态调用方法；Math没有构造方法，不能生成实例。 Math属性&amp;方法 描述 Math.random() 随机数 Math.round() 四舍五入 Math.ceil() 向上取整 Math.floor() 向下取整 Date对象： 1234var date = new Date(); // 当前日期和时间var time = date.getTime(); // 返回从 1970 年 1 月 1 日至今的毫秒数var year = date.getFullYear(); // 获取年份date.setFullYear(yyyy, mm, dd); // 设置具体的日期 详细了解JS内置对象请参考：JavaScript 对象参考手册； 2.4.3 创建对象1.原始方式一： 123456var obj = new Object();obj.name = "张三";obj.age = 22;obj.eat=function()&#123; alert(this.name+"吃馒头");&#125; 2.原始方式二： 1234567var obj = &#123; var name = "张三"; var age = 20; var eat = function()&#123; alert(this.name + "正在吃饭~"); &#125;&#125;; 3.工厂方式： 123456789function objectFactory(name,age)&#123; return &#123; name:name, age:age, eat:function()&#123; alert(this.name+"吃馒头"); &#125; &#125;&#125; 4.构造函数★： 1234567function Person(name,age)&#123; this.name=name, this.age=age, this.eat=function()&#123; console.log(this.name+"吃馒头"); &#125;&#125; this关键字：指向调用该方法的对象。 instanceof操作符：判断对象是否为类（构造方法）的一个实例。 12var obj = new Object();obj instanceof Object; // true 判断obj是否为Object的一个实例。 在 JavaScript 中，很多时候，你需要避免使用 new关键字。 2.5 JS原型JavaScript是一门面向对象的编程语言，Brendan Eich为JavaScript设计了继承机制，但为了简化继承，并未引入“类”的概念，而是采用构造函数直接生成实例，采用原型 (prototype) 共享通用数据。 2.5.1 构造函数Brendan Eich为JavaScript设计了继承机制，采用构造函数直接生成实例。 1234567// 构造函数function Person(name,age)&#123; this.name=name, this.age=age,&#125;// 使用[构造函数]生成实例var p1 = new Person("Tom",20); 2.5.2 原型对象引入prototype属性：使用构造函数直接生成实例，存在一个问题：无法共享通用数据。为了共享的通用属性和方法，Brendan Eich为构造函数设置了一个prototype属性，指向构造函数的原型对象。原型对象用于存放所有实例共享的通用属性和方法。构造函数每生成一个实例对象，将自动引用prototype对象中共享的属性和方法。 1234567891011// 构造函数function Person(name,age)&#123; this.name=name, this.age=age,&#125;// 原型对象：添加共享属性&amp;方法Person.prototype = &#123;species: '人类'&#125;// 使用[构造函数]生成一个实例var p1 = new Person("Tom",20);// 可调用共享属性alert(p1.species); // 人类 原型对象的属性：①__proto__：指向创建它的函数对象的原型对象；②constructor：指向构造函数； 1Obj.prototype.constructor = Obj 2.5.3 原型链原型链：JS对象（不论是普通对象还是函数对象）都有__proto__属性，指向创建它的函数对象的原型对象。通过__proto__向上遍历直到Object.prototype.__proto__ = null构成原型链。 注意：使用__proto__可使实例（子）获取构造器（父）的原型对象，容易造成不必要的麻烦。所以__proto__仅是为了实现原型链继承机制而存在的一个属性，不推荐在编程中使用。 2.5.4 原型继承原型继承：当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到相应的属性为止。原型继承的本质：由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像”继承”了prototype对象一样。 原型继承：设置[子类的原型]是[父类的实例]。 1son.prototype = new Father() 2.6 JS事件机制事件一般与函数配合使用，这样就可以使事件驱动函数执行。 2.6.1 事件类型事件三要素：事件源，事件名称，事件处理程序； 事件句柄 描述 onclick 鼠标单击 onfocus 元素获得焦点 onblur 元素失去焦点 onmouseover 鼠标覆盖 onmouseout 鼠标移开 onmouseup 鼠标点击 onmousedown 鼠标松开 onscroll 窗口滚动 onchange 发生改变 onload 加载完成 onunload 退出页面 onerror 加载错误 onsubmit 点击提交 onreset 点击重置 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 2.6.2 事件传播事件传播方式：①事件捕获：Window-&gt;Document -&gt; Element -&gt; Attribute -&gt; Text；②事件冒泡：Window&lt;-Document &lt;- Element &lt;- Attribute &lt;- Text；注意：focus blur scroll事件除外其它的大部分事件都会冒泡 阻止事件传播： 1event.stopPropagation() 2.6.3 事件注册注册/移除事件的三种方式：①on事件： 1事件源.onclick = function()&#123;&#125; ②addEventListener()： 12事件源.addEventListener('click',function()&#123;&#125;,[useCapture])// 捕获阶段：useCapture=true; 默认值为false；（IE9+） ③attachEvent()： 12事件源.attachEvent(eventName,function()&#123;&#125;,[useCapture])// 捕获阶段：useCapture=true; 默认值为false；（IE8-） 取消事件默认行为： ①阻止独享属性（on+event）绑定的事件的默认事件： 1return false; ②阻止通过addEventListener()添加的事件的默认事件： 1event.preventDefault(); ③阻止通过attachEvent()添加的事件的默认事件： 1event.returnValue = false; 3. JS DOMDOM文档对象模型 3.1 DOM获取页面元素1.根据id获取元素： 1document.getElementById("id"); // 返回单个元素 2.根据标签名获取元素数组： 1document.getElementByTagName("标签名"); // 返回数组 3.根据name获取元素数组： 1document.getElementByName("name"); // 返回数组 4.根据类名获取元素数组： 1document.getElememtByClassName("类名"); // 返回数组 5.根据选择器获取元素数组： 1document.querySelectorAll("选择器"); // 返回数组 3.2 DOM操作1.改变HTML输出流： 1document.write(); // 直接向HTML输出流写内容。 2.改变HTML内容： 12元素.innerText; // 获取/设置文本值（对代码转义为文本）元素.innerHTML; // 获取/设置HTML代码 3.改变HTML属性： 1元素.HTML属性 = 新属性值 // 改变HTML属性 4.自定义HTML属性 123元素.getAttribute("属性"); // 获取属性元素.setAttribute("属性","值") // 设置属性元素.removeAttribute("属性"); // 移除属性 5.改变CSS样式： 1元素.style.CSS样式 = 新样式 // 改变CSS样式 CSS属性名多个单词以-分隔s，JS调用CSS属性名多个单词采用驼峰命名；即在JS中使用fontSize来表示CSS中的font-size。 3.3 DOM节点DOM节点：文档Document-&gt;元素Element-&gt;属性Attribute-&gt;文本Text； 1.当前节点属性： 当前节点属性 描述 nodeName 文档节点：#document元素节点：标签名属性节点：属性名文本节点：#text nodeValue 元素节点：undefined / null属性节点：属性值文本节点：文本 nodeType 元素：1属性：2文本：3注释：8文档：9 innerHTML 读取：当前节点及后代节点的HTML代码写入：HTML代码，新的DOM树 innerText 读取：当前节点的文本内容写入：文本值（对html转义） textContent 当前节点及后代节点的文本内容 2.当前节点的相关节点： 当前节点的相关节点 描述 ownerDocument 所属文档 previousSibling 前一个同级节点 nextSibling 下一个同级节点 parentNode 父节点 parentElement 父元素 firstChild 子节点 children 子元素 3.针对父节点的操作： 针对父节点的DOM方法 描述 appendChild() 追加一个子节点 removeChild() 移除子节点 replaceChild() 替换子节点 insertBefore(new,old) 在旧节点前插入新节点 isEqualNode() 判断节点是否相同 4.创建节点： 创建节点 描述 createAttribute() 创建属性节点 createElement() 创建元素节点 createTextNode() 创建文本节点 5.自定义属性： 自定义属性 描述 getAttribute(“attr”) 获取属性 setAttribute(“attr”, “value”) 设置属性及属性值 removeAttribute(“attr”) 移除属性 4. JS BOMBOM浏览器对象模型，其中window对象是BOM顶级对象，document，location，history，navigator都是windows的子对象。 4.1 window-浏览器窗口window对象：浏览器窗口； window属性&amp;方法 描述 window.name window对象名称 window.innerHeight 浏览器窗口的内部高度 window.innerWidth 浏览器窗口的内部宽度 4.1.1 原生JS入口函数12// 原生JS入口函数：等待加载完页面元素后再执行JS代码window.onload = function()&#123; JS代码 &#125; // 原生JS入口函数 4.1.2 JS弹出框1.警告框： 1window.alert("警告"); // 警告框； 2.确认框： 12var flag = window.confirm("确定要删除？"); // 确认框；// 确定：返回true | 取消：返回false 3.提问框： 12var input = window.prompt("你的年龄？"); //提问框；// 确定：返回输入值 | 取消：返回null 可省略windows对象，直接使用。 4.1.3 JS定时器1.单次定时器： 1234// 设置单次定时器var timerId = window.setTimerout(function()&#123;定时任务&#125;,timeout); // 只执行一次// 清除单次定时器window.clearTimeout(timerId); 2.循环定时器： 1234// 设置循环定时器var timerId = window.setInterval(function()&#123;定时任务&#125;,timeout); // 循环执行// 清除循环定时器window.clearInterval(timerId); 可省略windows对象，直接使用。 1234567// 循环定时器：由单次定时器取消。var timer2 = setInterval(function()&#123; document.write(new Date());//输出当前时间&#125;,1000)setTimeout(function()&#123; clearInterval(timer2);//清除定时器timer2&#125;,5000) 4.2 location-浏览器urllocation对象：浏览器地址 location属性&amp;方法 描述 location.href 获取url location.protocol 返回所使用的 web 协议（http:// 或 https://） location.hostname 返回 web 主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回 web 主机的端口（80 或 443） location.assign() 加载页面 location.reload() 重新加载 url统一资源定位符：scheme://host:port/path?query#fragment url元素 描述 scheme 通信协议；如http，ftp，maito，https等 host 主机；服务器域名系统主机名、IP地址； port 端口；http默认端口80； path 路径； query 查询；可选，用于给动态网页传递参数；参数名1=值1&amp;参数名2=值2； fragment 信息片段；字符串，锚点； 4.3 history-会话历史history对象：会话历史 history属性&amp;方法 描述 back() 后退，go(-1) forword() 前进，go(1) go(n) 跳转n步 4.4 navigator-浏览器信息navigator对象：浏览器信息 navigator属性&amp;方法 描述 navigator.appName 浏览器名称 navigator.appVersion 浏览器版本 navigator.language 浏览器语言 navigator.platform 操作系统类型 navigator.userAgent 浏览器设定的User-Agent字符串]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web | CSS]]></title>
    <url>%2Fweb-css.html</url>
    <content type="text"><![CDATA[CSS（Cascading Style Sheets，层叠样式表），主要通过为HTML元素增添样式的方式修饰静态页面，实现了页面内容与样式分离。目前主流网页布局均采用 div+CSS 方式实现。 1. CSS基础1.1 CSS三大特性 层叠性：权重高的样式会覆盖权重低的样式； 继承性：子元素继承父元素的样式； 优先级：作用域越小，优先级越大； 不同级别：行内样式&gt;id选择器&gt;类选择器&gt;标签选择器&gt;通配符&gt;继承； 同一级别：后写的会覆盖先写的样式； 1.2 CSS语法规则CSS注释：/* CSS注释内容 */ 12345/* CSS注释内容 */选择器&#123; 样式属性1:值1; 样式属性2:值2;&#125; 1.3 引入CSS样式表1.行内样式表（内联表）： 1&lt;标签 style="属性1:值1;属性2:值2;"&gt;&lt;/标签&gt; 2.内部样式表（内嵌表） 123456&lt;style&gt; 选择器&#123; 样式属性1:值1; 样式属性2:值2; &#125;&lt;/style&gt; 3.外部样式表（外联表）：外部.css文件 4.引入外部样式表： 1&lt;link rel="stylesheet" type="text/css" href="url" /&gt; 5.三种样式表总结 样式表 优点 缺点 使用情况 控制范围 行内样式表 权重高 样式与结构未分离 较少 单个标签 内部样式表 样式与结构部分分离 未彻底分离 较多 整个页面 外部样式表 样式与结构完全分离 需引入 多，推荐 整个站点 2. CSS样式2.1 CSS字体-font★1.字体系列： 1font-family : "宋体","微软雅黑"; font-family是一个字体族的优先表，如果浏览器不支持第一个字体，则会尝试下一个。 2.字体风格： 123456font-style : normal/italic/oblique;/*- normal：标准- italic：斜体- oblique：倾斜*/ 3.字体粗细： 1234font-weight : 400;/* 加粗度：100,200,300,400,500,600,700,800,900 *//* normal=400 | blod=700 *//* bolder：更粗 | lighter：更细*/ 4.字体大小： 1font-size : px/em/% 5.font综合设置： 1font : font-style font-weight font-size/line-height font-family 1234注意：- ！英文字体名一般不需要加引号，设置英文字体名必须位于中文字体名之前；- ！加粗度没有单位，而且`x00`只有9个值，不存在`123`这种值；- ！网页普遍是`14px`；尽量设偶数px，奇数px在IE6存在bug； 2.2 CSS文本-text★1.文本缩进： 1text-indent : em/px/%; 2.水平对齐： 1text-align : left/center/right; 3.单词间隔（只适用于英文）: 1word-spacing : em/px; 4.字符间隔： 1letter-spacin : em/px; 5.文本装饰： 12345678text-decoration : none/underline/overline/line-through/blink;/* - none：无- underline：下划线- overline：上划线- line-through：穿过一条线- blink：闪*/ 6.行高： 12line-height : px/em/%; /* 一般文本行高比字号大7-8像素即可 */ 7.文本阴影： 1text-shadow : 水平位置 垂直位置 模糊偏移 阴影颜色; 8.【CSS3】颜色透明度： 12rgba(0~255, 0~255, 0~255, 0~1);/* 模糊度：0~1 */ 2.3 CSS背景-background★1.背景色： 1background-color：rgb(); 2.背景图： 1background-image : url(); 3.背景平铺： 1234567background-repeat : repeat/no-repeat;/*- repeat：平铺- no-repeat：不平铺- repeat-x：横向平铺- repeat-y：纵向平铺*/ 3.背景定位： 1234background-position : X坐标/位置 Y坐标/位置;/* 坐标：px/em/% *//* 位置：top，bottom，center，left，right； 若只设了一个值，那么第二个值将是center； */ 4.背景关联： 12345backgrount-attchment : fixed/scroll;/*- scroll：默认值。背景图像会随着页面其余部分的滚动而移动；- fixed：图像固定；当页面的其余部分滚动时，背景图像不会移动；*/ 5.背景综合设置： 1background: bg-color bg-image bg-repeat bg-attchment bg-position(x,y); 6.【CSS3】背景尺寸： 123456background-size : contain/cover;/*- contain：保证背景图片完整性；- cover：保证背景图片完全覆盖整个区域；- width&amp;height：设置背景的宽&amp;高；（一般设置1个参数，设置2个参数会导致图片变形）*/ 2.4 *CSS列表-list-style1.列表项标志： 12345678list-style-type : none/disc/circle/square/decimal...;/* none：无disc：实心圆circle：空心圆square：实心方块decimal：数字*/ 2.列表项图像： 1list-style-image : url(); 3.列表标志位置： 12345list-style-position : inside/outside;/*outside：默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。inside：列表项目标记放置在文本以内，且环绕文本根据标记对齐。*/ 4.列表综合设置： 1list-style : image type position; 2.5 *CSS表格1.折叠边框 1border-collapse : collapse; 2.水平对齐 1text-align : left/center/right; 3.垂直对齐 1vertical-align : top/center/bottom; 4.空单元格显示/隐藏 1empty-cells : show/hide; 5.表格标题在上/在下 1caption-side : top/bottom; 2.6 *CSS轮廓-outline1.轮廓颜色： 1outline-color : rgb() 2.轮廓样式： 1234567outline-style : solid/dotted/dashed/double...;/*- soild：实线- dotted：点线- dashed：虚线- double：双实线*/ 3.轮廓宽度： 123456outline-width : thick/medium/thin/px;/*- thick：粗- medium：中- thin：细*/ 4.轮廓综合设置： 1outline : color style width; 2.7 标签显示模式★ display 描述 none 不显示 block 块级元素 inline 行内元素 inline-block 行内块元素 2.8 内容溢出盒子★ overflow 描述 visible 默认值。内容溢出部分显示在盒子外； hidden 隐藏内容溢出部分 scroll 如果内容溢出会被修剪，则浏览器会显示滚动条以便查看其余的内容； auto 如果内容溢出被修剪，则浏览器会显示滚动条以便查看其余的内容； 3. CSS选择器3.1 元素选择器123标签&#123; 属性:值;&#125; 3.2 类选择器123.类名&#123; 属性:值;&#125; 单类名调用：class=&quot;类名&quot;；多类名调用：class=&quot;类名1 类名2 ...&quot;； 3.3 id选择器123#id&#123; 属性:值;&#125; 3.4 通配符选择器123*&#123; 属性:值;&#125; 作用域：整个HTML页面 3.5 交集选择器123选择器1选择器2&#123; 属性:值;&#125; 3.6 并集选择器123选择器1,选择器2&#123; 属性:值;&#125; 3.7 后代选择器★123先代选择器 后代选择器&#123; 属性:值;&#125; 作用于先代元素内的[所有的后代元素]； 3.8 子元素选择器★123父选择器 &gt; 子选择器&#123; 属性:值;&#125; 只作用于父元素内的[直接子元素]； 3.9 相邻兄弟选择器123伯选择器 + 仲选择器&#123; 属性:值;&#125; 作用于紧接在伯元素后的[仲元素]； 3.10 属性选择器123[属性]&#123; 属性:值;&#125; 123标签[属性=值]&#123; 属性:值;&#125; 3.11 伪类选择器123选择器:伪类&#123; 属性:值;&#125; 1.&lt;a&gt;链接伪类： a:link：未访问的链接； a:visited：已访问的链接； a:hover：鼠标移动到链接； a:active：鼠标点击时的连接； 2.位置结构伪类： first-child：第一个子元素； last-child：最后一个子元素； nth-child(n)：第n个元素（n=1,2,3…）； nth-last-child(n)：倒数第n个元素（n=1,2,3…）;[n=odd：奇数 | n=even：偶数] 123注意：- ！不是第一个HTML标签，而是第一个HTML元素 html元素：文本，图像，链接； 3.【CSS3】目标伪类： 1234/*:target 选择器用于选取当前活动的目标元素*/:target&#123; 属性:值;&#125; 3.12 伪元素选择器123标签::伪元素&#123; 属性:值;&#125; 伪元素： first-line：第一行； first-letter：第一个字符； before：在标签之前添加content:新内容； 123标签::before&#123; content:新内容;&#125; after：在标签之后添加content:新内容； 123标签::after&#123; content:新内容;&#125; selection：选中区域； 4. CSS框模型（Box Model）★ 4.1 边框-border1.边框宽度： 1border-width : px; 2.边框样式： 1234567border-style : solid/dashed/dotted/double;/*- solid：实线- dashed：虚线- dotted：点线- double：双实线*/ 3.边框颜色： 1border-color : rgb(); 4.边框综合设置： 1border : width style color; 5.单边边框： 12border-top/right/bottom/left-属性:值;/* 单独设置某一边，设置方式与border同理 */ 6.圆角边框： 1border-radius : 左上角半径px 右上角半径px 右下角半径px 左下角半径px; 4.2 内边距-padding1.内边距： 1padding : top-px right-px bottom-px left-px 2.单边内边距： 1padding-top/right/bottom/left : px 4.3 外边距-margin1.外边距： 1margin:top-px right-px bottom-px left-px; 2.单边外边距： 1margin-top/right/bottom/left : px; 123456border/padding/margin综合设置提示：- 可设置四个参数，分别对应top-right-bottom-left，顺时针遍历设置；- 若只设置了1个value，则top=right=bottom=left=value；- 若只设置了2个value，则top=val_1,right=val_2,bottom=val_1,left=val_2；顺时针遍历赋值；- 若只设置了3个value，则top=val_1,right=val_2,bottom=val_3,left=val_1；顺时针遍历赋值；- border-radius半径设置顺序：左上-右上-右下-坐下；顺时针遍历； 4.4 垂直外边距合并现象★1.相邻盒子垂直外边距合并，margin合并取最大值； &nbsp;&nbsp;&nbsp;解决方案：只设置一个margin； 2.嵌套盒子垂直外边距合并。 &nbsp;&nbsp;&nbsp;解决方案①：overflow:hidden； &nbsp;&nbsp;&nbsp;解决方案②：使用border，padding； 4.5 CSS3盒子&amp;IE6盒子 IE6框模型：box-sizing:content-box 12IE6框的大小：【width+左右padding+左右border+左右margin】 ×【height+上下padding+上下border+上下margin】 CSS3框模型：box-sizing:border-box 12CSS3框的大小：【width+左右margin】×【height+上下margin】 - CSS3盒的[width&amp;height]包含[padding+border] 5. 浮动5.1 浮动-float（难点）浮动：浮动块不在文档流中，不占文档流位置；但占浮动位置。 1float:left/right; （未完待详细解释） 5.2 清除浮动-clear★clear 属性规定元素的哪一侧不允许其他浮动元素。 1clear:left/right/both 清除浮动的方式： 1.【W3C推荐】在盒子末尾再添加一个如下的空盒子： 1&lt;div style="clear:both;"&gt;&lt;/div&gt; 2.在盒子样式中添加溢出隐藏样式： 1overflow:hidden 3.为盒子添加如下样式，在每次结束后都清除浮动： 1.clearfix:after&#123;clear:both&#125; /* 只适用于IE6、IE7。 */ 6. 定位6.1 定位简介（难点） position 是否占文档流 定位策略 static：静态定位 占文档流 fixed：固定定位 不占文档流 相对于视窗进行定位 relative：相对定位 占文档流原位置 相对于原位置进行边偏移 absolute：绝对定位 不占文档流 相对于其已定位的包含块定位 6.2 边偏移 前提：float || position || 不占文档流； 边偏移：top，bottom，left，right； 6.3 相对定位★1position:relative 1.相对于在文档流中的原位置进行边偏移； 2.仍占据文档流中的原位置； 6.4 绝对定位★1position:absolute 1.相对于[其已定位的包含块]进行边偏移； 2.已从文档流中完全删除，就好像该元素原来不存在一样； 3.元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框； 4.绝对定位与文档流无关，所以可以覆盖在页面其他元素上； 5.可通过z-index控制堆叠次序；z-index 仅能在定位元素上奏效； 6.一般采取[子绝父相]策略； 7. 页面日常开发习惯页面布局：div+CSS； 使用外部样式表，引入外部.css文件； 例行设置： 1231.清除盒子内外边距：*&#123;padding:0;margin:0;&#125;；2.链接取消下划线：a&#123;text-decoration:none&#125;；3.列表取消列表项标志：ul&#123;list-style:none&#125;； 功能型样式： 123-外边距实现盒子水平居中：margin:0 auto；-垂直居中：line-height:盒高；-清除浮动：&lt;div style="clear:both;"&gt;&lt;/div&gt;； 附：CSS长度 相对长度单位 描述 px 像素值 em 相对于当前字符的尺寸（自适应） % 百分比 绝对长度单位 描述 cm 厘米 mm 毫米 in 英寸 pt 磅（1pt=1/72英寸） CSS颜色 单位 描述 color_name 颜色名称（如red） rgb(0~255,0~255,0~255) RGB值（如rgb(0,0,0)） rgb(x%,x%,x%) RGB百分比值（如rgb(100%,0%,0%)） #rrggbb 十六进制数（如#c3c3c3）]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web | HTML]]></title>
    <url>%2Fweb-html.html</url>
    <content type="text"><![CDATA[HTML（Hyper Text Mark-up Language，超文本标记语言），一种使用标记标签 (tag) 描述网页的语言，其中的“超文本“是指页面内除文本之外还可以包含图片、链接、程序、音频、视频等非文字元素。HTML 常用于编写页面主体结构，CSS 常用于对页面进行静态修饰，JavaScript 常用于对网页增加动态功能。 1. HTML基本结构HTML注释：&lt;!-- HTML注释格式 --&gt; 12345678910&lt;!-- HTML注释格式 --&gt;&lt;!-- 基本HTML文档格式 --&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文档主体内容&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!-- 标准HTML文档格式 --&gt;&lt;!DOCTYPE html&gt; &lt;!-- H5文档类型=html --&gt;&lt;html lang="en"&gt; &lt;!-- language=English --&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- 字符集 --&gt; &lt;!-- 屏幕自适应大小 --&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文档主体内容&lt;/body&gt;&lt;/html&gt; 2. HTML-头部标签2.1 meta标签-元信息(1) meta标签：页面元信息，位于&lt;head&gt;&lt;/head&gt;中。 12&lt;meta name="" content=""/&gt;&lt;meta http-equiv="" content=""/&gt; (2) meta标签属性：键值对 name:content http-equiv:content &lt;meta/&gt;属性 值 描述 content some_text 定义与 http-equiv 或 name 属性相关的元信息 name authordescriptionkeywordsgeneratorrevisedothers 把 content 属性关联到一个name。 http-equiv content-typeexpiresrefreshset-cookie 把 content 属性关联到 http 头部 scheme some_text 定义用于翻译 content 属性值的格式 例如： 123&lt;title&gt;京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！&lt;/title&gt;&lt;meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"&gt;&lt;meta name="Keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"&gt; 2.2 link标签-链接外部资源1234&lt;!--链接外部css文件--&gt;&lt;link rel="stylesheet" type="text/css" href="文件url" /&gt; &lt;!--链接icon文件--&gt;&lt;link rel="icon" href="favicon.ico" /&gt; 2.3 base标签-基准链接base标签：为页面所有链接规定默认url或默认target。 1&lt;base href="" target="" /&gt; &lt;base/&gt;属性 值 描述 herf url 规定页面所有链接的默认url target _self_blank 规定页面所有链接的默认打开方式 3. HTML标签HTML元素：从开始标签（start tag）到结束标签（end tag）的所有代码； 空元素：没有内容的 HTML 元素；推荐在开始标签中关闭；如&lt;br/&gt;； 3.1 HTML标签分类按标签类型分类： 标签类型 标签 单标签 &lt;br/&gt;，&lt;img/&gt;，&lt;input/&gt;… 双标签 &lt;p&gt;&lt;/p&gt;，&lt;div&gt;&lt;/div&gt;… 按标签显示模式分类： 标签显示模式 标签 块级元素 &lt;div&gt;&lt;/div&gt;，&lt;ul&gt;&lt;/ul&gt;… 行级元素 &lt;span&gt;&lt;/span&gt;，&lt;a&gt;&lt;/a&gt;… 行内块元素 &lt;img/&gt;、&lt;td&gt;&lt;/td&gt;… 3.2 HTML标签属性HTML标签属性格式：name=”value” ； 例如： 属性 值 描述 id id 规定元素的唯一 id class classname 规定元素的类名（classname） style style_definition 规定元素的行内样式（inline-style） title text 规定元素的额外信息（可在工具提示中显示） 详细参考《HTML标准属性参考手册》 3.3 排版标签 排版标签 标题标签 &lt;h1&gt;一级标题&lt;/h1&gt;~&lt;h6&gt;六级标题&lt;/h6&gt; 段落标签 &lt;p&gt;这是一个段落&lt;/p&gt; 换行标签 &lt;br/&gt; 水平线标签 &lt;hr/&gt; 块标签 &lt;div&gt;&lt;/div&gt; 行标签 &lt;span&gt;&lt;/span&gt; 3.4 文本格式化标签 文本格式 HTML4 HTML5 加粗 &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt; 斜体 &lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; 下划线 &lt;u&gt;&lt;/u&gt;不推荐使用 &lt;ins&gt;&lt;/ins&gt; 删除线 &lt;s&gt;&lt;/s&gt;不推荐使用 &lt;del&gt;&lt;/del&gt; 3.5 图片标签-img★1&lt;img src="url" alt="替代文本" /&gt; &lt;img/&gt;属性 值 描述 src url 本地图片路径 / 网络图片url alt text 图片非正常显示的替代文本 width&amp;height px，% 设置图像宽&amp;高 title text 鼠标悬停时的显示文本 border px 图像边框宽度 避免图片失真：推荐width&amp;height只设置一个值； 3.6 链接标签-a★1&lt;a herf="url" target="_blank"&gt;&lt;/a&gt; &lt;a&gt;属性 值 描述 href url 超链接url / #id target _self_blank 本标签页打开（默认）新标签页打开 name text 锚点名称 锚点定位： 1&lt;a href="#id/name"&gt;&lt;/a&gt; 3.7 列表标签3.7.1 无序列表-ul1234&lt;ul&gt; &lt;li&gt;表项1&lt;/li&gt; &lt;li&gt;表项2&lt;/li&gt;&lt;/ul&gt; 3.7.2 有序列表-ol1234&lt;ol&gt; &lt;li&gt;表项1&lt;/li&gt; &lt;li&gt;表项2&lt;/li&gt;&lt;/ol&gt; 3.7.3 自定义列表-dl12345678&lt;dl&gt; &lt;dt&gt;上级表项1&lt;/dt&gt; &lt;dd&gt;下级表项11&lt;/dd&gt; &lt;dd&gt;下级表项12&lt;/dd&gt; &lt;dt&gt;上级表项2&lt;/dt&gt; &lt;dd&gt;下级表项21&lt;/dd&gt; &lt;dd&gt;下级表项22&lt;/dd&gt;&lt;/dl&gt; 列表项计数问题：从1开始计数，dl从dt开始计数； 3.8 表格标签-table123456789101112131415161718&lt;table border="1px"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头1&lt;/th&gt; &lt;th&gt;表头2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;第1行第1格&lt;/td&gt; &lt;td&gt;第1行第2格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第2行第1格&lt;/td&gt; &lt;td&gt;第2行第2格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 空单元格边框未显示问题：在空单元格中添加一个空格占位符&amp;nbsp;； &lt;table&gt;属性： border：设置边框； cellspaceing：单元格间距； cellpadding：单元格边距； &lt;td&gt;属性： 合并单元格：rowspan=&quot;&quot;跨行， colspan=&quot;&quot;跨列； 水平对齐方式：align=&quot;left/center/right&quot;； 3.9 表单标签-form123&lt;form action="" method="GET"&gt; 表单域：表单元素；&lt;/form&gt; &lt;form&gt;属性 值 描述 action url 规定提交表单的目的地址url method GETPOST 规定提交表单使用的 HTTP 方法 target _self_blank 规定action的打开方式 HTTP 方法： GET：表单数据在地址栏可见，明文；（默认） POST：表单数据在地址栏不可见，密文； 3.9.1 input标签★1&lt;input type="" name="" value="" /&gt; &lt;input/&gt;属性 值 描述 type textpasswordradiocheckboxbuttonsubmitresetimagefile 单行文本输入框密码输入框单选框复选框普通按钮提交按钮重置按钮图片文件 name 用户自定义 input控件名称 value 用户自定义 input控件初始文本值 checked checked 定义选框预选项 disabled disabled 禁用表单元素 size number 字段显示宽度 maxlength number 字段最大长度 H5新增input属性： &lt;input/&gt;属性（H5） 值 描述 placeholder text 输入字段的提示 autofocus autofocus 规定在页面加载时是否获得焦点 （不适用于 type=”hidden”） multiple multiple 多文件上传 autocomplete onoff 是否使用字段的自动完成功能 required required 必填项，不能为空 H5新增input type值： input type值（H5） 描述 email 邮箱格式 tel 手机号码 url url格式 number 数字格式 search 搜索框 range 自由拖动滑块 time 时分 date 年月日 datetime 时间 month 月年 week 星期 年 3.9.2 label标签label标签：为 input 元素定义标注1&lt;label for=""&gt;&lt;/label&gt; &lt;label&gt;属性 值 描述 for id 规定 label 绑定到哪个表单元素。 form form_id 规定 label 字段所属的一个或多个表单。 3.9.3 select标签-下拉列表1234&lt;select name="" id=""&gt; &lt;option value=""&gt;下拉项1&lt;/option&gt; &lt;option value=""&gt;下拉项2&lt;/option&gt;&lt;/select&gt; &lt;option&gt;属性 值 描述 selected selected 定义下拉列表预选项 disabled disabled 禁用表单元素 value text 定义送往服务器的选项值 3.9.4 textarea标签-文本域123&lt;textarea name="" id="" cols="30" rows="10"&gt; 文本域：多行文本&lt;/textarea&gt; rows&amp;cols：定义文本的可见行&amp;列； 3.9.5 fieldset标签-元素分组12345&lt;fieldset&gt; &lt;legend&gt;元素组标题&lt;/legend&gt; 表单元素1: &lt;input type="text" /&gt; 表单元素2: &lt;input type="text" /&gt;&lt;/fieldset&gt; 3.9.6 datalist标签-input可能值（H5）datalist标签：定义选项列表。与 input 连用，定义 input 可能的值。 123456&lt;input list="datalist-id" /&gt;&lt;datalist id="datalist-id"&gt; &lt;option value="input可能值_01"&gt; &lt;option value="input可能值_02"&gt; &lt;option value="input可能值_03"&gt;&lt;/datalist&gt; 3.10 多媒体标签3.10.1 embed标签-嵌入内容1&lt;embed src="" type=""/&gt; &lt;embed/&gt;属性 值 描述 src url 嵌入内容的url type type 嵌入内容的类型 width&amp;height px 嵌入内容的宽&amp;高 3.10.2 audio标签-音频1&lt;audio src=""&gt;&lt;/audio&gt; &lt;audio&gt;属性 值 描述 src url 音频的url autoplay autoplay 自动播放 control control 显示音频控件 loop loop 循环播放 3.10.3 video标签-视频1&lt;video src=""&gt;&lt;/video&gt; &lt;video&gt;属性 值 描述 src url 音频的url autoplay autoplay 自动播放 control control 显示视频控件 loop loop 循环播放 width&amp;height px 视频的宽&amp;高 4. HTML代码约束 始终首行声明文档类型&lt;!DOCTYPE html&gt;； 建议关闭所有 HTML 元素；空元素，推荐在开始标签中关闭； HTML标签对大小写不敏感，推荐使用小写标签；]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
</search>
